<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端综合面试题</title>
      <link href="/fe-mianshi.html"/>
      <url>/fe-mianshi.html</url>
      
        <content type="html"><![CDATA[<h2 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h2><ol><li><p>link是HTML标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；@import是css语法，只有导入样式表的作用。</p></li><li><p>加载页面时，link会和HTML同时加载，而@import将会在页面加载完毕之后被加载。</p></li><li><p>兼容性区别，@import是CSS2.1才有的语法，故只可在IE5+才能识别；link标签作为HTML元素，不存在兼容性问题。</p></li><li><p>DOM操作，DOM可以操作link中的样式，而不可以操作@import中的样式。</p><mark class="hl-label red">网上有一种声音说link权重比@import高，其实并没有，具体大家可以自己实践。</mark> </li></ol><h2 id="img标签-alt和title的区别"><a href="#img标签-alt和title的区别" class="headerlink" title="img标签 alt和title的区别"></a>img标签 alt和title的区别</h2><p>title：鼠标移入图片显示的值<br>alt：图片无法加载时显示的图片<br>在SEO的层面上，爬虫抓取不到图片的内容，所以在写img标签的时候为了增加SEO效果可以用alt属性来描述这张图的内容或者关键词</p><h2 id="substr和substring的区别"><a href="#substr和substring的区别" class="headerlink" title="substr和substring的区别"></a>substr和substring的区别</h2><blockquote><p><strong>1.  substr 是从起始索引号开始提取指定长度的字符</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">//输出结果为bcd</span></span><br></pre></td></tr></table></figure><p>substr(<mark class="hl-label blue">1</mark> ,<mark class="hl-label green">3</mark> ) 即表示从b(索引号<mark class="hl-label blue">1</mark> )开始提取3（<mark class="hl-label green">3</mark> ）个字符。也可以说提取索引<mark class="hl-label blue">1</mark> 到索引为<mark class="hl-label green">3</mark> 的位置，取头取尾</p><blockquote><p><strong>2.  substring是提取字符串中两个指定索引号之间的字符。</strong></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">substr</span>(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">//输出结果为bc</span></span><br></pre></td></tr></table></figure><p>substring(<mark class="hl-label blue">1</mark> ,<mark class="hl-label green">3</mark> ) 即表示提取从(索引号<mark class="hl-label blue">1</mark> )到（索引号<mark class="hl-label green">3</mark> ）之间的字符（不包括<mark class="hl-label green">3</mark> ），取头不取尾。</p><h2 id="slice和splice的区别"><a href="#slice和splice的区别" class="headerlink" title="slice和splice的区别"></a>slice和splice的区别</h2><blockquote><p> 相同点：都是对数组进行截取。</p><p> 不同点：slice不会改变原数组，但是splice会直接改变原数组。</p></blockquote><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><blockquote><p><strong><code>slice()</code></strong> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</p></blockquote><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><blockquote><p><strong><code>splice()</code></strong> 方法通过删除或替换现有元素或者原地<code>添加</code>新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">splice</span>(start[, deleteCount[, item1[, item2[, ...]]]])</span><br><span class="line"><span class="comment">//    起始索引  要删除的个数（可选） 要添加的元素</span></span><br></pre></td></tr></table></figure><h2 id="js数据类型和数据类型检测"><a href="#js数据类型和数据类型检测" class="headerlink" title="js数据类型和数据类型检测"></a>js数据类型和数据类型检测</h2><h3 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h3><blockquote><ol><li>简单（基本）类型：String、Number、Boolean、Undefined、Null、Symbol</li><li>引用（复杂）类型：Object、Array、Function</li></ol></blockquote><h3 id="检测数据类型方法"><a href="#检测数据类型方法" class="headerlink" title="检测数据类型方法"></a>检测数据类型方法</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><strong>typeof</strong></h4><blockquote><p>  一般用于检测基本数据类型，因为它检测引用（复杂）数据类型都会返回Objcet</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fun) <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> arr)<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>了解一下：typeof null返回值是object，因为js中的数据在底层是以二进制存储，如果前三位为0，那么就会判定为object，而null的所有都为0 ，所以null会被检测为object</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><blockquote><p>instanceof是一个双目判断运算符，a instanceOf b ,判断a的构造器是否为b（其实只要a与b在一个原型链中就会返回true）返回一个布尔值。</p></blockquote> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="keyword">function</span>(<span class="params"></span>)&#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> obj =&#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> arr = [ ]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这个方法主要是用来检测复杂数据类型的，不能用来检测基本数据类型，可以理解为用来检测构造函数的prototype属性是否出现在对象原型链中的任意位置，只要在当前实例的原型链上，我们用其检测出来的结果都是 true。在类的原型继承中，我们最后检测出来的结果未必准确。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">//false </span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>instanceof运算符直接访问的变量的原始值，不会自动建立包装类。因此不能用来判断基本数据类型。</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h4><blockquote><p><strong>语法：</strong>实例.constructor</p><p>对象的原型链下（构造函数的原型下）有一个属性，叫constructor, <strong>constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。</strong></p><p>缺点：constructor并不可靠，因为它容易被修改。</p></blockquote><h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><blockquote><p>Object.prototype.toString.call()应该是目前最准确最常用的方式了，可以用来检测所有数据类型。在Object.prototype上有一个toString方法,这个方法执行的时候,会返回方法中this关键字对应数据值的数据类型,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Object.prototype.toString() -&gt;返回的是 Object.prototype 的数据类型 -&gt;&quot;[object Object]&quot;</span><br><span class="line">//f.toString() -&gt;返回的是f的数据类型 -&gt;&quot;[object Object]&quot;</span><br></pre></td></tr></table></figure><p>也就是，我想知道谁的所属类信息，我们就把这个toString方法执行，并且让this变为我们检测的这个数据值，那么方法返回的结果就是当前检测这个值得所属类信息 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">12</span>)<span class="comment">//[boject Number]</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)<span class="comment">//[boject Boolean]</span></span><br><span class="line">    <span class="comment">//&quot;[object Number]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object String]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Object]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Function]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Boolean]&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="事件循环—宏任务微任务"><a href="#事件循环—宏任务微任务" class="headerlink" title="事件循环—宏任务微任务"></a>事件循环—宏任务微任务</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>简单来说浅拷贝就是只<strong>拷贝一层</strong>。</p><p>深拷贝就不会像浅拷贝那样只拷贝一层，而是有多少层我就拷贝多少层</p><p><a href="https://blog.csdn.net/jiang7701037/article/details/98738487">https://blog.csdn.net/jiang7701037/article/details/98738487</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Vuex?</title>
      <link href="/fe-vuex.html"/>
      <url>/fe-vuex.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h2><p>vuex官方是这么介绍的</p><blockquote><p> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><p>vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间数据的共享。</p><h2 id="使用vuex的好处"><a href="#使用vuex的好处" class="headerlink" title="使用vuex的好处"></a>使用vuex的好处</h2><p>1.能够在vuex中集中管理共享的数据，易于开发和后期维护。</p><p>2.能够高效地实现组件之间的数据共享，提高开发效率。</p><p>3.vuex中存储的数据都是响应式的，能够实时保持数据与页面同步。</p><h2 id="使用vuex的场景"><a href="#使用vuex的场景" class="headerlink" title="使用vuex的场景"></a>使用vuex的场景</h2><p>一般来说，只有组件之间共享的数据才有必要存储到vuex中，组件的私有数据依旧存储在组件自身的data中即可。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const store =new Vuex.Store(&#123;</span><br><span class="line">//state中存放的就是全局共享的数据</span><br><span class="line">state:&#123;count:0&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h2><p><a href="https://imgtu.com/i/jXCy6J"><img src="https://s1.ax1x.com/2022/07/23/jXCy6J.png" alt="vue官网图"></a></p><blockquote><p>vuex的核心概念：state、mutations、actions、getters、modules。上图是官网上的流程图，我们来分析一下每一环的作用</p></blockquote><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote><p>单一状态树，state提供唯一的公共数据源，提供唯一公共数据</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//创建store数据源，提供唯一公共数据</span><br><span class="line">const store = new Vuex.Store(&#123;</span><br><span class="line">state:&#123; count:0 &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="组件访问state中数据的第一种方式"><a href="#组件访问state中数据的第一种方式" class="headerlink" title="组件访问state中数据的第一种方式"></a>组件访问state中数据的第一种方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.$store.state.全局数据名称</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;当前count值为：&#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;</span><br><span class="line">//在template中this可以忽略</span><br></pre></td></tr></table></figure><h4 id="组件访问state中数据的第二种方式"><a href="#组件访问state中数据的第二种方式" class="headerlink" title="组件访问state中数据的第二种方式"></a>组件访问state中数据的第二种方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//1.在组件中从vuex按需导入mapstate函数</span><br><span class="line">import &#123; mapstate &#125; from &#x27;vuex&#x27;</span><br></pre></td></tr></table></figure><p>通过刚才导入的mapstate函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//2.将全局数据映射为当前组件的计算属性</span><br><span class="line">computed:&#123;</span><br><span class="line">...mapstate([&#x27;count&#x27;])</span><br><span class="line">// ...为展开运算符</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中即可直接使用count</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;当前count值为：&#123;&#123; count &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><blockquote><p><strong>组件修改state中的数据</strong></p></blockquote><h4 id="错误操作"><a href="#错误操作" class="headerlink" title="错误操作"></a>错误操作</h4><p>我们想要实现点击按钮改变count的数值的话，可能会想给按钮添加一个@click事件让他数值+1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据&lt;p&gt;当前count值为：&#123;&#123; $store.state.count &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;button @click=&quot;countAdd&quot;&gt; +1 &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  countAdd()&#123;</span><br><span class="line">    this.$store.state.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意：mutations在处理异步操作时，能够引起页面的响应式变化，但是 devtools 无法进行监听。</p><h4 id="正确操作"><a href="#正确操作" class="headerlink" title="正确操作"></a>正确操作</h4><p>正确的操作应该是使用Mutation</p><blockquote><p>在vuex中只能通过mutation变更Store数据，不可以直接操作Store中的数据。</p><p>通过这种方式虽然操作起来繁琐了一些，但是可以集中监控所有数据的变化。不然到项目后期根本不知道是在哪个地方修改了数据，不利于维护。</p></blockquote><h4 id="定义mutation"><a href="#定义mutation" class="headerlink" title="定义mutation"></a>定义mutation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count:0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state)&#123;</span><br><span class="line">      //变更状态</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="触发mutation"><a href="#触发mutation" class="headerlink" title="触发mutation"></a>触发mutation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//触发mutation</span><br><span class="line">methods:&#123;</span><br><span class="line">  countAdd()&#123;</span><br><span class="line">    //触发mutations的第一种方式</span><br><span class="line">    this.$store.commit(&#x27;add&#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>commit的作用就是调用某个mutation函数</p></blockquote><h4 id="触发mutation时传递参数"><a href="#触发mutation时传递参数" class="headerlink" title="触发mutation时传递参数"></a>触发mutation时传递参数</h4><p>如果我们不是让数值+1，而是加任意值该怎么做呢？可以在触发mutations时传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count:0</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    //在这里加上形参</span><br><span class="line">    addN(state,step)&#123;</span><br><span class="line">      //变更状态</span><br><span class="line">      state.count+= step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="触发携带参数的mutation"><a href="#触发携带参数的mutation" class="headerlink" title="触发携带参数的mutation"></a>触发携带参数的mutation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  countAdd()&#123;</span><br><span class="line">    //触发mutations时携带参数</span><br><span class="line">    this.$store.commit(&#x27;addN&#x27;,3)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label blue">注意：在大多数情况下，传递的参数（载荷）应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读</mark> <h4 id="触发mutations的第二种方式"><a href="#触发mutations的第二种方式" class="headerlink" title="触发mutations的第二种方式"></a>触发mutations的第二种方式</h4><p>上面this.$store.commit()是出发mutations的第一种方式，下面介绍一下第二种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从vuex中按需导入mapMutations函数</span><br><span class="line">import &#123; mapMutations &#125; from &#x27;vuex&#x27;</span><br></pre></td></tr></table></figure><p>通过导入的mapMutations函数，将需要的mutations函数映射为当前组件的methods方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  ...mapMutations([&#x27;add&#x27;,&#x27;addN&#x27;]),</span><br><span class="line">  countAdd()&#123;</span><br><span class="line">    //可以直接调用add或者addN</span><br><span class="line">    this.add()</span><br><span class="line">    this.addN(5)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote><p>如果通过异步操作变更数据，建议（必须）通过Action，而不能使用Mutation。但是在Action中还是要通过触发Mutation的方式间接变更数据。</p></blockquote><p>不要在mutations中执行异步操作，比如想点击按钮一秒后再让数据变化，在mutation中写定时器这种操作是有问题的<br>我们的解决方案是用Action，它是专门用来处理异步任务的。这样 devtools 就能够进行跟踪，由 Actions 处理异步操作，具体的函数部分仍交由 Mutations 进行处理。</p><p><img src="https://s1.ax1x.com/2022/07/26/vSkneO.png" alt="同步任务，异步任务"></p><h4 id="定义Action"><a href="#定义Action" class="headerlink" title="定义Action"></a>定义Action</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line"> //省略其他代码</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add(state)&#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  actions:&#123;</span><br><span class="line">  //context：上下文，默认写法</span><br><span class="line">    addAsync(context)&#123;</span><br><span class="line">      //这里只负责执行setTimeout延迟操作</span><br><span class="line">      setTimeout(()=&gt;&#123;</span><br><span class="line">      //修改数据的操作提交给mutation</span><br><span class="line">        context.commit(&#x27;add&#x27;)</span><br><span class="line">      &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="触发Action"><a href="#触发Action" class="headerlink" title="触发Action"></a>触发Action</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  countAdd()&#123;</span><br><span class="line">    //触发actions的第一种方式</span><br><span class="line">    this.$store.dispatch(&#x27;addAsync&#x27;)</span><br><span class="line">    //dispatch函数专门用来触发action</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="触发携带参数的Action"><a href="#触发携带参数的Action" class="headerlink" title="触发携带参数的Action"></a>触发携带参数的Action</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//定义Action</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line"> //省略其他代码</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    addN(state,step)&#123;</span><br><span class="line">      state.count += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  actions:&#123;</span><br><span class="line">    //传入形参</span><br><span class="line">    addAsync(context,step)&#123;</span><br><span class="line">      setTimeout(()=&gt;&#123;</span><br><span class="line">        //实参</span><br><span class="line">        context.commit(&#x27;addN&#x27;,step)</span><br><span class="line">      &#125;,1000)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//触发Action</span><br><span class="line">methods:&#123;</span><br><span class="line">  countAdd()&#123;</span><br><span class="line">    //调用dispatch，携带参数</span><br><span class="line">    this.$store.dispatch(&#x27;addNAsync&#x27;,5)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="触发mutations的第二种方式-1"><a href="#触发mutations的第二种方式-1" class="headerlink" title="触发mutations的第二种方式"></a>触发mutations的第二种方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//从vuex中按需导入mapActions函数</span><br><span class="line">import &#123; mapActions &#125; from &#x27;vuex&#x27;</span><br></pre></td></tr></table></figure><p>通过导入的mapActions函数，将需要的Actions函数映射为当前组件的methods方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  ...mapActions([&#x27;add&#x27;,&#x27;addN&#x27;]),//需要用哪个就定义哪个</span><br><span class="line">  countAdd()&#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% label 注意：</span><br><span class="line">//...mapActions([&#x27;add&#x27;,&#x27;addN&#x27;]) 这里的add和addN已经被映射为当前组件的方法，可以直接绑定在click事件上</span><br><span class="line">如：&lt;button @click=&quot;addN(5)&quot;&gt;+5 acync&lt;/button&gt; green %&#125;</span><br></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><blockquote><p>Getter用于对Store中的数据进行加工处理形成新的数据，不会修改Store中的原数据。类似于计算属性，在数据展示前进行一些变化处理，具有缓存功能，能够提高运行效率。</p></blockquote><h4 id="定义Getter"><a href="#定义Getter" class="headerlink" title="定义Getter"></a>定义Getter</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count:0</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    showNum: state =&gt;&#123;</span><br><span class="line">    return &#x27;当前最新的数量是【&#x27;+ state.count +&#x27;】&#x27;  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用getters的第一种方式"><a href="#使用getters的第一种方式" class="headerlink" title="使用getters的第一种方式"></a>使用getters的第一种方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.$store.getters.名称</span><br><span class="line">&lt;p&gt; &#123;&#123; $store.getter.showNum &#125;&#125; &lt;/p&gt;</span><br><span class="line">//template中this可以省略</span><br></pre></td></tr></table></figure><h4 id="使用getters的第二种方式"><a href="#使用getters的第二种方式" class="headerlink" title="使用getters的第二种方式"></a>使用getters的第二种方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import &#123; mapGetters &#125; from &#x27;vuex&#x27;</span><br><span class="line"></span><br><span class="line">computed:&#123;</span><br><span class="line">  ...mapGetters(&#123;&#x27;showNum&#x27;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里vuex中的核心我们已经都了解了，那我们再总结一下</p><p><img src="https://s1.ax1x.com/2022/07/25/jvJVje.png" alt="总结"></p><h2 id="完结撒花🎉"><a href="#完结撒花🎉" class="headerlink" title="完结撒花🎉"></a>完结撒花🎉</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BFC？它的作用是什么以及怎么创建BFC区域</title>
      <link href="/fe-bfc.html"/>
      <url>/fe-bfc.html</url>
      
        <content type="html"><![CDATA[<h2 id="啥是BFC"><a href="#啥是BFC" class="headerlink" title="啥是BFC"></a>啥是BFC</h2><h2 id="看不明白的定义："><a href="#看不明白的定义：" class="headerlink" title="看不明白的定义："></a><strong>看不明白的定义：</strong></h2><p>BFC (Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><p><strong>官方文档到中是这么介绍的</strong>：</p><blockquote><p>一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素，BFC是一块块独立的渲染区域，可以将BFC看成是元素的一种属性，拥有了这种属性的元素就会使他的子元素与世隔绝，不会影响到外部其他元素。</p></blockquote><h2 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h2><p>还不是很清楚什么意思？上代码！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设father和son盒子都是BFC区域<br>id&#x3D;”father”这个BFC区域包含了所有 class&#x3D;”1”的盒子但<strong>不包含</strong>class&#x3D;”2”的盒子<br>id&#x3D;”son”的这个BFC区域则包含了所以class&#x3D;”2”的盒子。<br>那么总结下来可以得到如下结论：<br>1.每一个BFC区域只包括它的子元素，并不包括子元素的子元素。<br>2.每个BFC区域都是独立隔绝开来的，互相不会受到影响。</p><h2 id="怎么创建BFC？"><a href="#怎么创建BFC？" class="headerlink" title="怎么创建BFC？"></a>怎么创建BFC？</h2><ol><li>根元素</li><li>float属性不为none</li><li>overflow不为visible</li><li>position为absolute或fixed</li><li>display为inline-block， table-cell， table-caption， flex， inline-flex</li></ol><h2 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h2><p>既然知道了BFC是咋回事，也知道了怎么创建BFC，那么它的作用是什么呢？</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>浮动会导致父元素高度塌陷，相信刚开始学html的同学们都记得overflow: hidden可以清除浮动，但是听说BFC之前却不清楚原理，经过上边的解释后就知道了是因为在BFC区域内子元素是不会影响到外部元素的。</p><h3 id="解决外边距塌陷"><a href="#解决外边距塌陷" class="headerlink" title="解决外边距塌陷"></a>解决外边距塌陷</h3><p>前端布局离不开margin，那么肯定会遇到外边距塌陷的问题</p><p><img src="https://s1.ax1x.com/2022/07/22/jOrC59.png" alt="外边距塌陷"></p><p>如图，我们给两个盒子分别设置了100px的外边距，两个盒子之间的外边距应该有200px，但是现在只有100px，那么根据刚开始我们的理解，只要给这两个盒子都加一个父盒子并设置为BFC区域就应该能解决这个问题，马上动手验证</p><p><img src="https://s1.ax1x.com/2022/07/22/jOrNVg.png" alt="解决外边距塌陷"></p><p>可以看到果然是正确的解决了外边距塌陷的问题。</p><h3 id="解决包含塌陷"><a href="#解决包含塌陷" class="headerlink" title="解决包含塌陷"></a>解决包含塌陷</h3><p><img src="https://s1.ax1x.com/2022/07/22/jOsdeO.png" alt="包含塌陷"></p><p>从上图可以看出我本来是给子盒子margin-top让他离父盒子顶部30px，但是却导致子盒子带着父盒子整体往下跑了30px，我们想要的效果却没有出来，要实现我们想要的效果有两个办法，一就是用padding，二就是把父盒子变成BFC区域，我们当然是选择第二种</p><p><img src="https://s1.ax1x.com/2022/07/22/jOs7pn.png" alt="解决包含塌陷"><br>完美解决！</p><h3 id="暂时完结，后续再补充"><a href="#暂时完结，后续再补充" class="headerlink" title="暂时完结，后续再补充"></a>暂时完结，后续再补充</h3>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--css篇</title>
      <link href="/fe-css.html"/>
      <url>/fe-css.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--html篇</title>
      <link href="/FE-html.html"/>
      <url>/FE-html.html</url>
      
        <content type="html"><![CDATA[<h2 id="html5有哪些新特性？"><a href="#html5有哪些新特性？" class="headerlink" title="html5有哪些新特性？"></a>html5有哪些新特性？</h2><p>答：html5新增和移除了一些元素</p><p>新增了以下几大类元素：</p><p>内容元素：article、footer、header、nav、section。<br>表单控件：calendar、date、time、email、url、search。<br>控件元素：webworker, websockt, Geolocation。</p><p>移除的元素有下列这些：</p><p>显现层元素：basefont，big，center，font, s，strike，tt，u。<br>性能较差元素：frame，frameset，noframes。</p><p>HTML5已形成了最终的标准，概括来讲，它主要是关于图像，位置，存储，多任务等功能的增加。<br>新增的元素有绘画 canvas ，用于媒介回放的 video 和 audio 元素，本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失，而sessionStorage的数据在浏览器关闭后自动删除。<br>新的技术：canvas,svg,webworker, websocket, Geolocation</p><h2 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h2><p>答：</p><p>（1）HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；<br>（2）即使在没有样式CSS的情况下也能以一种文档格式显示，并且是容易阅读的；<br>（3）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；<br>（4）使阅读源代码的人更容易将网站分块，便于阅读、维护和理解。</p><h2 id="Doctype作用-严格模式混杂模式"><a href="#Doctype作用-严格模式混杂模式" class="headerlink" title="Doctype作用?严格模式混杂模式"></a>Doctype作用?严格模式混杂模式</h2><p>答：</p><p>（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。<br>（2）严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。<br>（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>（4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p><h2 id="浏览器内核的理解"><a href="#浏览器内核的理解" class="headerlink" title="浏览器内核的理解"></a>浏览器内核的理解</h2><p>答：</p><p> 浏览器内核（Rendering Engine），直译过来的意思是渲染引擎，它指浏览器最核心的部分，负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。</p><p> 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p><h3 id="常见的内核"><a href="#常见的内核" class="headerlink" title="常见的内核"></a>常见的内核</h3><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite&#x2F;SeaMonkey等。<br>Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为、Blink;]<br>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]<br>EdgeHTML内核：Microsoft Edge。  [此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性]。</p><h2 id="对WEB标准以及W3C的理解"><a href="#对WEB标准以及W3C的理解" class="headerlink" title="对WEB标准以及W3C的理解"></a>对WEB标准以及W3C的理解</h2><p>Web标准一般是将结构、表现、行为独立分开，使其更具有模块化。</p><p>W3C标准是对web标准提出规范化要求，比如：标签字母要小写，双标签要闭合，标签不允许随意嵌套。</p><p>好处是：文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果手机免越狱微信双开</title>
      <link href="/iphone-wechat.html"/>
      <url>/iphone-wechat.html</url>
      
        <content type="html"><![CDATA[<p> <strong>苹果免越狱微信双开</strong></p><p>事情的起因是我姐姐因工作需要两个微信，但是众所周知苹果手机官方是没有双开这个功能的，并且由于微信系统封闭，所以很难像安卓手机一样轻松的解决。</p><p> <strong>废话少说直接上教程</strong></p><h2 id="下载并安装需要的软件"><a href="#下载并安装需要的软件" class="headerlink" title="下载并安装需要的软件"></a>下载并安装需要的软件</h2><h2 id="下载最新版本iTunes、iCloud"><a href="#下载最新版本iTunes、iCloud" class="headerlink" title="下载最新版本iTunes、iCloud"></a>下载最新版本iTunes、iCloud</h2><p><a href="https://www.apple.com/itunes/download/win64">点我下载iTunes</a>。</p><p>或者去iTunes官网<a href="https://www.apple.com.cn/itunes/">https://www.apple.com.cn/itunes/</a></p><p><a href="https://updates.cdn-apple.com/2020/windows/001-39935-20200911-1A70AA56-F448-11EA-8CC0-99D41950005E/iCloudSetup.exe">点我下载iCloud</a>。</p><p>或者去iCloud官网<a href="https://support.apple.com/zh-cn/HT204283">https://support.apple.com/zh-cn/HT204283</a></p><h2 id="下载安装Altstore"><a href="#下载安装Altstore" class="headerlink" title="下载安装Altstore"></a>下载安装Altstore</h2><p>官网地址<a href="https://altstore.io/">https://altstore.io</a></p><h2 id="安装事项"><a href="#安装事项" class="headerlink" title="安装事项"></a>安装事项</h2><p><strong>注意：上面这三个软件安装的时候，最好 右键-用管理员身份运行（altstore解压出来安装），要不然可能会出现问题</strong></p><h2 id="连接手机"><a href="#连接手机" class="headerlink" title="连接手机"></a>连接手机</h2><p> <strong>安装完之后三个软件都打开（Altstore没有应用界面，电脑右下角有菱形图标就代表已经启动了），然后把手机连上电脑，iTunes上对当前电脑授权</strong><br><img src="https://s1.ax1x.com/2022/07/10/jsMoWT.png" alt="jsMoWT.png"></p><p><strong>手机弹窗点信任</strong><br><img src="https://s1.ax1x.com/2022/07/10/jsM7SU.png" alt="jsM7SU.png"><br> <strong>iTunes连接成功后把这两个同步选项勾选上</strong><br><img src="https://s1.ax1x.com/2022/07/10/jsM5F0.png" alt="jsM5F0.png"></p><h2 id="手机安装Altstore"><a href="#手机安装Altstore" class="headerlink" title="手机安装Altstore"></a>手机安装Altstore</h2><p><strong>在右下角任务栏，右键AltStore选择install AltStore - 你的iphone,上面步骤中如果需要输入id和密码正常操作就可以</strong></p><p><img src="https://s1.ax1x.com/2022/07/10/jsQ29K.png" alt="jsQ29K.png"></p><p>等待一会儿，如果提示installation succeeded就代表安装成功了。这时候你手机上应该成功安装上了altstore，安装完成后，需要在系统设置内选择“通用”-“描述文件与设备管理”-进行信任证书。</p><p><img src="https://s1.ax1x.com/2022/07/10/jsQ7Nt.png" alt="jsQ7Nt.png"></p><h2 id="重头戏：微信二号"><a href="#重头戏：微信二号" class="headerlink" title="重头戏：微信二号"></a>重头戏：微信二号</h2><h2 id="下载我修改好的微信"><a href="#下载我修改好的微信" class="headerlink" title="下载我修改好的微信"></a>下载我修改好的微信</h2><p><strong>这一步真的是折腾了好久，之前在网上找的教程要么是没有微信安装包要么是安装包用不了，一直提示the app name is invalid或者 the app is invalid，最后终于修改打包出来了一个能用的，废话不多说直接上链接</strong></p><p>&#96;链接: <a href="https://pan.baidu.com/s/1Wt675l1_m7jp8qa-rbH7sA?pwd=lhxd">https://pan.baidu.com/s/1Wt675l1_m7jp8qa-rbH7sA?pwd=lhxd</a> 提取码: lhxd</p><h2 id="下载后发送到手机"><a href="#下载后发送到手机" class="headerlink" title="下载后发送到手机"></a>下载后发送到手机</h2><p>这一步最简单的办法是直接在电脑上用微信文件助手传给手机，然后手机接受完打开方式选择第二个，也就是AleStore<br><img src="https://s1.ax1x.com/2022/07/11/jcJSxI.png" alt="jcJSxI.png"></p><h2 id="手机安装微信2号"><a href="#手机安装微信2号" class="headerlink" title="手机安装微信2号"></a>手机安装微信2号</h2><p><strong>手机端AltStore按步骤操作即可</strong><br>需要输入id和密码就正常输，最后看altStore里面有微信就代表成功了，这时候返回桌面就可以看到第二个微信就可以正常使用了</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意：此方法为个人签名，有效期只有七天，马上要过期的时候只要电脑和手机链接同一个wifi即可续签，记得每七天要续签一次</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iPhone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的远程控制软件</title>
      <link href="/remote-control.html"/>
      <url>/remote-control.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p><strong>如果需要我远程控制你的电脑的话，按照以下教程操作即可</strong></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>先下载远程控制软件ToDesk <a href="https://dl.todesk.com/windows/ToDesk_Lite_x64.exe">点我下载</a>或者去<a href="https://www.todesk.com/">官网</a>下载(精简版免安装)</p><p><img src="https://s1.ax1x.com/2022/07/07/jwNpVA.png" alt="推荐精简版" title="精简版免安装"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>下载完打开软件，然后截图发给我（如下图）</p><p>注意：如果连接密码是隐藏的话，点击后边的小眼睛图标把密码显示出来</p><p><img src="https://s1.ax1x.com/2022/07/07/jwNk28.png" alt="软件截图" title="把图片发给我"></p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程控制 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
