<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>全自动薅JD羊毛</title>
      <link href="/jd-yangmao.html"/>
      <url>/jd-yangmao.html</url>
      
        <content type="html"><![CDATA[<p>薅羊毛也一年多了，一直没有写个教程，因为获取ck的方式总是失效，每次跟朋友说新的方法总是比较费事要说好多次，所以还是总结一下文档，省事🤣，这篇文档我会一直更新。</p><br/><h2 id="流程简介-可以不看"><a href="#流程简介-可以不看" class="headerlink" title="流程简介(可以不看)"></a>流程简介(可以不看)</h2><p>1.获取ck</p><blockquote><p>相当于你的账号证明，有这个才有你的账号权限帮你完成任务，每次获取账号，有效期为一个月</p></blockquote><p>2.绑定服务器<mark class="hl-label pink">只需操作一次</mark>  </p><blockquote><p>获取了你的账号之后要把你的账号怎么给我呢？没错 绑定我的服务器，下载软件后只需要绑定一次即可，不用每次操作。</p></blockquote><p>3.提交代挂</p><blockquote><p>绑定了服务器之后，肯定是要提交啦，提交到我的服务器上才能帮你跑脚本</p></blockquote><p>4.接入一对一通知<mark class="hl-label pink">只需操作一次，非必须</mark>   </p><blockquote><p>这个墙裂建议所有人都操作，虽然是非必要的，这个东西的功能就是把你自己账号的信息推送到你的微信上。</p></blockquote><h2 id="第一步安装软件"><a href="#第一步安装软件" class="headerlink" title="第一步安装软件"></a>第一步安装软件</h2><p>首先<code>安卓</code>手机安装获取ck的软件，苹果手机没有。这里建议下载豆多多，下方的教程也是按照豆多多来的：<a href="http://jdc.zzux.com:86/">点我下载软件</a></p><h2 id="第二步绑定服务器"><a href="#第二步绑定服务器" class="headerlink" title="第二步绑定服务器"></a>第二步绑定服务器</h2><p>安装完成之后打开软件，点击右上角—密钥提交，在输入框中输入  <a href="http://jdc.zzux.com:5555/">http://jdc.zzux.com:5555</a>  点击确定即可。</p><p><img src="https://pic.imgdb.cn/item/640dc449f144a0100780cf3e.jpg"></p><h2 id="第三步添加账号"><a href="#第三步添加账号" class="headerlink" title="第三步添加账号"></a>第三步添加账号</h2><p>点击首页的添加账号按钮，登陆完成后账户信息会自动出现在首页，就代表登录成功了，<mark class="hl-label pink">但是这一步完成了不代表就万事大吉了</mark>  ，因为你还没有提交到我的服务器，所以接着还有一步</p><p><img src="https://pic.imgdb.cn/item/640dc585f144a01007830b65.jpg"></p><h2 id="第四步提交代挂"><a href="#第四步提交代挂" class="headerlink" title="第四步提交代挂"></a>第四步提交代挂</h2><p>这时候长按你的账号或者点击一下会有提交代挂的按钮，点击后选择服务器然后确定就好了。这时候已经可以给你的账号自动做任务，领京豆了。</p><h2 id="最后一对一通知"><a href="#最后一对一通知" class="headerlink" title="最后一对一通知"></a>最后一对一通知</h2><p><img src="https://wxpusher.zjiecode.com/api/qrcode/YP05yu8biqC6tQzUGFpx0Tah3PN7OwQybW42FYMC3gvjb0HRxRWZrNQ0QJP2XMGR.jpg" alt="微信扫码"></p><p>这个东西的作用就是把你账号的信息单独发送给你，账号过期了也会单独推送通知你账号过期。正常时每天晚上9：30发送通知。</p><p>使用方法就是扫描二维码之后，点击–我的–我的UID，这时候就会把你的UID发送给你，然后把这个uid复制一下，在提交代挂的时候写道备注里面，这个也是只用操作一次就可以了。</p><p><img src="https://pic.imgdb.cn/item/640de4cff144a01007cb7b7e.jpg"><img src="https://pic.imgdb.cn/item/640de75ef144a01007d0a3f1.jpg" alt="" style="zoom:80%;" /></p><h2 id="更新账号"><a href="#更新账号" class="headerlink" title="更新账号"></a>更新账号</h2><p>账号过期之后想重新登录的操作就很简单了。只需要重复第三第四步骤就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 必看 </category>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 薅羊毛 </tag>
            
            <tag> 必看 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序知识点（二）</title>
      <link href="/mini-program-2.html"/>
      <url>/mini-program-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="小程序数据绑定"><a href="#小程序数据绑定" class="headerlink" title="小程序数据绑定"></a>小程序数据绑定</h2><h3 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h3><ul><li><p>在 data 中定义数据</p><blockquote><p>在页面对应的 .js 文件中，把数据定义到data对象中即可</p></blockquote></li><li><p>在 WXML 中使用数据</p><blockquote><p>把data中的数据绑定到页面中渲染，使用 Mustache 语法（双大括号）将变量包起来即可。</p><p><view>  </view></p><p>图片的src属性也可以使用 Mustache 语法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>:&#123;</span><br><span class="line">  <span class="attr">imgSrc</span>:<span class="string">&#x27;http://xxxxxxx.png&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//页面结构如下</span></span><br><span class="line">&lt;image src=<span class="string">&quot;&#123;&#123;imgSrc&#125;&#125;&quot;</span>&gt;&lt;/image&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h2><table><thead><tr><th align="center">类型</th><th align="center">绑定方式</th><th align="center">事件描述</th></tr></thead><tbody><tr><td align="center">tap</td><td align="center">bindtap 或 bind:tap</td><td align="center">手指触摸后马上离开，类似HTML中 click 点击事件</td></tr><tr><td align="center">input</td><td align="center">bindinput 或 bind:input</td><td align="center">文本框的输入事件</td></tr><tr><td align="center">change</td><td align="center">bindchange 或 bind:change</td><td align="center">状态改变时触发</td></tr></tbody></table><h3 id="事件对象的属性列表"><a href="#事件对象的属性列表" class="headerlink" title="事件对象的属性列表"></a>事件对象的属性列表</h3><blockquote><p>当事件回调触发的时候，会收到一个事件对象 event ，它的详细属性如下表所示：</p></blockquote><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">type</td><td align="center">string</td><td align="center">事件类型</td></tr><tr><td align="center">timeStamp</td><td align="center">integer</td><td align="center">页面打开到触发事件所经过的毫秒数</td></tr><tr><td align="center"><em><strong>target</strong></em></td><td align="center">Object</td><td align="center"><em><strong>触发事件的组件的一些属性值集合</strong></em></td></tr><tr><td align="center">currentTarget</td><td align="center">Object</td><td align="center">当前组件的一些属性值集合</td></tr><tr><td align="center"><strong>detail</strong></td><td align="center">Object</td><td align="center"><strong>额外的信息</strong></td></tr><tr><td align="center">touches</td><td align="center">Array</td><td align="center">触摸事件，当前停留在屏幕中的触摸点信息的数组</td></tr><tr><td align="center">changedTouches</td><td align="center">Array</td><td align="center">触摸事件，当前变化的触摸点信息的数组</td></tr></tbody></table><h3 id="target-和-currentTarget的区别"><a href="#target-和-currentTarget的区别" class="headerlink" title="target 和 currentTarget的区别"></a>target 和 currentTarget的区别</h3><blockquote><p>target是触发该事件的源头组件，而currentTarget 则是当前事件所绑定的组件。</p><p><img src="https://s1.ax1x.com/2022/11/28/zagFyt.png" alt="事件"></p><p>点击内部的按钮时，点击事件以冒泡的方式向外扩散，也会触发外层view的tap事件处理函数。</p><p>此时对于外层的view来说：</p><p>e.target指向的是触发事件的源头组件，因此，e.target是内部的按钮组件<br>e.currentTarget指向的是当前正在触发事件的那个组件，因此，e.currentTarget是当前的view组件</p><p>大白话来说：因为点了button按钮，然后向上冒泡才执行了bindtap，源头是button。</p></blockquote><h3 id="bindtap的语法格式"><a href="#bindtap的语法格式" class="headerlink" title="bindtap的语法格式"></a>bindtap的语法格式</h3><p>在小程序中，不存在HTML中的onclick鼠标点击事件，而是通过tap事件来响应用户的触摸行为。</p><ol><li><p>通过bindtap,可以为组件绑定tap触摸事件，语法如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnTapHandler&quot;</span>&gt;</span> 按钮 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在页面的js文件中定义对应的事件处理函数，事件参数通过形参event(一般简写成e)来接收：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">    <span class="title function_">btnTapHandler</span>(<span class="params">e</span>)&#123; <span class="comment">//按钮的tap事件处理函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(e) <span class="comment">//事件参数对象 e</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="在事件处理函数中为-data-中的数据赋值"><a href="#在事件处理函数中为-data-中的数据赋值" class="headerlink" title="在事件处理函数中为 data 中的数据赋值"></a>在事件处理函数中为 data 中的数据赋值</h3><p>通过调用this.setData(dataObject)方法，可以给页面data中的数据重新赋值，示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">data:&#123;</span><br><span class="line">count:0</span><br><span class="line">&#125;,</span><br><span class="line">//修改count的值</span><br><span class="line">changeCount()&#123;</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">  count:this.data.count 1</span><br><span class="line">)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="事件传参"><a href="#事件传参" class="headerlink" title="事件传参"></a>事件传参</h3><p>小程序中的事件传参比较特殊，不能在绑定事件的同时为事件处理函数传递参数。例如，下面的代码将不能正常工作：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">bindtap</span>=<span class="string">&#x27;btnHandler(123)&#x27;</span>&gt;</span>事件传参<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为小程序会把bindtap的属性值，统一当作事件名称来处理，相当于要调用一个名称为btnHandler(123)的事件处理函数。</p><blockquote><p>可以为组件提供data-* 自定义属性传参，其中*代表的是参数的名字，示例代码如下：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;btnHandler&quot;</span><span class="attr">data-info</span>=<span class="string">&quot;&#123;&#123;2&#125;&#125;&quot;</span>&gt;</span>事件传参<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最终：</p><ul><li>info 会被解析为 参数的名字</li><li>数值 2 会被解析为参数的值</li></ul><p>在事件处理函数中，通过event.target.dataset..参数名即可获取到具体参数的值，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">btnHandler</span>(<span class="params">event</span>)&#123;</span><br><span class="line"><span class="comment">//dataset是一个对象，包含了所有通过data-*传递过来的参数项</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">dataset</span>)</span><br><span class="line"><span class="comment">//通过dataset可以访问到具体参数的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">target</span>.<span class="property">dataset</span>.<span class="property">info</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bindinput语法"><a href="#bindinput语法" class="headerlink" title="bindinput语法"></a>bindinput语法</h3><p>在小程序中，通过input事件来响应文本框的输入事件，语法格式如下：</p><ol><li><p>通过bindinput,可以为文本框绑定输入事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">bindinput</span>=<span class="string">&quot;inputHandler&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在页面的jS文件中定义事件处理函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">inputHandler</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="comment">//e.detail.value是变化过后，文本框最新的值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">detail</span>.<span class="property">value</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="文本框和-data-数据同步"><a href="#文本框和-data-数据同步" class="headerlink" title="文本框和 data 数据同步"></a>文本框和 data 数据同步</h3><ol><li><p>定义数据</p></li><li><p>渲染结构</p></li><li><p>绑定input事件处理函数</p><p>代码如下：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input value=&quot;&#123;&#123;msg&#125;&#125;&quot;bindinput=&quot;inputHandler&quot;&gt;&lt;/input&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文本框内容改变的事件</span></span><br><span class="line"><span class="title function_">iptHandler</span>(<span class="params">e</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="comment">//通过e.detail.value获取到文本框最新的值</span></span><br><span class="line"><span class="attr">msg</span>:e.<span class="property">detail</span>.<span class="property">value</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>在小程序中，使用wx:if&#x3D;”{condition}”来判断是否需要渲染该代码块：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;condition&#125;&#125;&quot;</span>&gt;</span>True <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以用 wx:elif 和 wx:else 来添加else判断</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;type ==1&#125;&#125;&quot;</span>&gt;</span> 男 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123;type ==2&#125;&#125;&quot;</span>&gt;</span> 女 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span> 保密 &lt;view</span><br></pre></td></tr></table></figure><h3 id="结合-lt-block-gt-使用-wx-if"><a href="#结合-lt-block-gt-使用-wx-if" class="headerlink" title="结合 &lt; block &gt; 使用 wx:if"></a>结合 &lt; block &gt; 使用 wx:if</h3><p>如果要一次性控制多个组件的展示与隐藏，可以使用一个<block></block>标签将多个组件包装起来，并在&lt; block &gt;标签上使用 wx:if 控制属性，示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>view1 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>view2 <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：&lt; block &gt;并不是一个组件，它只是一个包裹性质的容器，不会在页面中做任何渲染，我们只会看到view。</p><h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h3><p>在小程序中，直接使用hidden&#x3D;”“也能控制元素的显示与隐藏：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">hidden</span>=<span class="string">&quot;&#123;&#123;condition&#125;&#125;&quot;</span>&gt;</span>条件为true陷藏，条件为false显示<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="wx-if-与-hidden-的对比"><a href="#wx-if-与-hidden-的对比" class="headerlink" title="wx:if 与 hidden 的对比"></a>wx:if 与 hidden 的对比</h3><ol><li>运行方式不同<ul><li>wx:if 以 <strong>动态创建和移除元素</strong> 的方式，控制元素的展示与隐藏</li><li>hidden <strong>以切换样式</strong>的方式（display: none&#x2F;block;）控制元素的显示与隐藏</li></ul></li><li>使用建议<ul><li>频繁切换时，建议使用hidden</li><li>控制条件复杂时，建议使用wx:if搭配wx:elif、wx:else进行展示与隐藏的切换</li></ul></li></ol><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h2><h3 id="wx-for"><a href="#wx-for" class="headerlink" title="wx:for"></a>wx:for</h3><p>通过wx:for可以根据指定的数组，循环渲染重复的组件结构，语法示例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">索引是：&#123;&#123;index&#125;&#125; 当前项是：&#123;&#123;item&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="手动指定索引和当前项的变量名"><a href="#手动指定索引和当前项的变量名" class="headerlink" title="手动指定索引和当前项的变量名"></a>手动指定索引和当前项的变量名</h3><ul><li>使用 wx:for-index 可以指定<strong>当前循环项的索引</strong>的变量名</li><li>使用 wx:for-item 可以指定当前项的变量名</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;array&#125;&#125;&quot;</span> <span class="attr">wx:for-index</span>=<span class="string">&quot;idx” wx:for-item=&quot;</span><span class="attr">itemName</span>&quot;&gt;</span></span><br><span class="line"> 索引是：&#123;&#123;idx&#125;&#125; 当前项是：&#123;&#123;itemName&#125;&#125;</span><br><span class="line"> <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="wx-key的使用"><a href="#wx-key的使用" class="headerlink" title="wx:key的使用"></a>wx:key的使用</h3><p>类似于Vue 列表渲染中的 :key，小程序在实现列表渲染时，也建议为渲染出来的列表项指定唯一的key值,<br>从而提高渲染的效率，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data 数据</span></span><br><span class="line"> <span class="attr">data</span>:&#123;</span><br><span class="line">   <span class="attr">userList</span>: [</span><br><span class="line">  &#123;<span class="attr">id</span>:<span class="number">1</span>, <span class="attr">name</span>:<span class="string">&#x27;小红’&#125;,</span></span><br><span class="line"><span class="string"> &#123;id:2, name：&#x27;</span>小黄’&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>，<span class="attr">name</span>: <span class="string">&#x27;小白’&#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> // wxml 结构</span></span><br><span class="line"><span class="string"> &lt;view wx:for=&quot;&#123;&#123;userList&#125;&#125;&quot; wx:key=&quot;id&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/view&gt;</span></span><br></pre></td></tr></table></figure><h2 id="WXSS"><a href="#WXSS" class="headerlink" title="WXSS"></a>WXSS</h2><h3 id="WXSS-和-CSS的关系"><a href="#WXSS-和-CSS的关系" class="headerlink" title="WXSS 和 CSS的关系"></a>WXSS 和 CSS的关系</h3><p>WXSS具有CSS大部分特性，同时，WXSS还对CSS进行了扩充以及修改，以适应微信小程序的开发。</p><p>与CSS相比，WXSS 扩展的特性有:</p><ul><li><p>rpx尺寸单位</p><blockquote><p>rpx(responsive pixel）是微信小程序独有的，用来解决屏适配的尺寸单位。</p><p>原理：把所有设备的屏幕在宽度上等分为750份，小程序在不同设备上运行的时候，会自动把rpx的样式单位换算成对应的像素单位来渲染。</p></blockquote></li><li><p>@import样式导入</p><blockquote><p>@import 后跟需要导入的外联样式表的相对路径，用；表示语句结束。示例如下:</p></blockquote></li></ul><p>​</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**比如有一个common.wxss**/</span></span><br><span class="line">-------</span><br><span class="line"><span class="comment">/**在app.wxss中**/</span></span><br><span class="line"><span class="keyword">@import</span> ”common.wxss“;</span><br><span class="line"><span class="comment">/**注意要用分号结尾**/</span></span><br><span class="line">    <span class="selector-class">.middle-p</span>&#123;</span><br><span class="line">        <span class="attribute">padding</span>:<span class="number">15px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局样式、局部样式"><a href="#全局样式、局部样式" class="headerlink" title="全局样式、局部样式"></a>全局样式、局部样式</h3><ol><li><p>全局样式</p><blockquote><p>定义在 app.wxss 中的样式为全局样式，作用于每一个页面。</p></blockquote></li><li><blockquote><p>在页面的.Wxss文件中定义的样式为局部样式，只作用于当前页面。</p><p>① 当局部样式和全局样式冲突时，根据就近原则，局部样式会覆盖全局样式<br>② 当局部样式的权重大于或等于全局样式的权重时，才会覆盖全局的样式</p></blockquote></li></ol><h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><h3 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h3><p>小程序根目录下的 app.json 文件是小程序的全局配置文件。常用的配置项如下:</p><ul><li><p>pages</p><p>记录当前小程序所有页面的存放路径</p></li><li><p>window</p><p>全局设置小程序窗口的外观</p></li><li><p>tabBar</p><p>设置小程序底部的 tabBar 效果</p></li><li><p>style</p><p>是否启用新版的组件样式</p></li></ul><h3 id="window节点常用配置"><a href="#window节点常用配置" class="headerlink" title="window节点常用配置"></a>window节点常用配置</h3><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>navigationBarTitleText</td><td>String</td><td>字符串</td><td>导航栏标题文字内容</td></tr><tr><td>navigationBarBackgroundColor</td><td>HexColor</td><td>#000000</td><td>导航栏背景颜色，如#000000</td></tr><tr><td>navigationBarTextStyle</td><td>String</td><td>white</td><td>导航栏标题颜色，仅支持 black&#x2F; white</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>#ffffff</td><td>窗口的背景色</td></tr><tr><td>backgroundTextStyle</td><td>String</td><td>dark</td><td>下拉loading 的样式，仅支持 dark &#x2F; light</td></tr><tr><td>enablePullDownRefresh</td><td>Boolean</td><td>false</td><td>是否全局开启下拉刷新</td></tr><tr><td>onReachBottomDistance</td><td>Number</td><td>50</td><td>页面上拉触底事件触发时距页面底部距离，单位为px</td></tr></tbody></table><h3 id="模拟器的问题"><a href="#模拟器的问题" class="headerlink" title="模拟器的问题"></a>模拟器的问题</h3><p>模拟器会有bug，并不能百分百还原手机上的效果，以真机为准。</p><h3 id="上拉触底的距离"><a href="#上拉触底的距离" class="headerlink" title="上拉触底的距离"></a>上拉触底的距离</h3><blockquote><p>概念：上拉触底是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而加载更多数据的行为。</p></blockquote><p>设置步骤：app.json -&gt; window -&gt; 为 onReachBottomDistance设置新的数值</p><p>注意：默认距离为50px，如果没有特殊需求，建议使用默认值即可。</p><h3 id="tabBar"><a href="#tabBar" class="headerlink" title="tabBar"></a>tabBar</h3><p>tabBar是移动端应用常见的页面效果，用于实现多页面的快速切换。小程序中通常将其分为：</p><ul><li><p>底部 tabBar</p></li><li><p>顶部 tabBar</p></li></ul><p>tabBar中只能配置最少2个、最多5个tab页签。当渲染顶部 tabBar 时，不显示icon，只显示文本</p><h3 id="tabBar的6个组成部分"><a href="#tabBar的6个组成部分" class="headerlink" title="tabBar的6个组成部分"></a>tabBar的6个组成部分</h3><ul><li>backgroundColor:tabBar 的背景色</li><li>selectedlconPath：选中时的图片路径</li><li>borderStyle:tabBar上边框的颜色</li><li>iconPath：未选中时的图片路径</li><li>selectedColor:tab上的文字选中时的颜色</li><li>color tab上文字的默认（未选中）颜色</li></ul><h3 id="tabBar配置"><a href="#tabBar配置" class="headerlink" title="tabBar配置"></a>tabBar配置</h3><p>在app.json中添加 “tabBar”:{}, 配置对象，配置项如下：</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>position</td><td>String</td><td>否</td><td>bottom</td><td>tabBar 的位置，仅支持 bottom&#x2F;top</td></tr><tr><td>borderStyle</td><td>String</td><td>否</td><td>black</td><td>tabBar上边框的颜色，仅支持 black&#x2F;white</td></tr><tr><td>color</td><td>HexColor</td><td>否</td><td></td><td>tab上文字的默认（未选中）颜色</td></tr><tr><td>selectedColor</td><td>HexColor</td><td>否</td><td></td><td>tab上的文字选中时的颜色</td></tr><tr><td>backgroundColor</td><td>HexColor</td><td>否</td><td></td><td>tabBar 的背景色</td></tr><tr><td>list</td><td>Array</td><td>是</td><td></td><td>最少2个、最多5个tab</td></tr></tbody></table><p>每个tab项的配置选项</p><table><thead><tr><th>属性</th><th>类型</th><th>必填</th><th>描述</th></tr></thead><tbody><tr><td>pagePath</td><td>String</td><td>是</td><td>页面路径，页面必须在 pages 中预先定义</td></tr><tr><td>text</td><td>String</td><td>是</td><td>tab上显示的文字</td></tr><tr><td>iconPath</td><td>String</td><td>否</td><td>未选中时的图标路径；当postion 为top 时，不显示icon</td></tr><tr><td>selectedlconPath</td><td>String</td><td>否</td><td>选中时的图标路径；当postion为top时，不显示 icon</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;tabBar&quot;</span>:&#123;</span><br><span class="line">  <span class="string">&quot;list&quot;</span>：[</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">  <span class="string">&quot;text&quot;</span>: <span class="string">&quot;index&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="string">&quot;pagePath&quot;</span>: <span class="string">&quot;pages/test/test&quot;</span>,</span><br><span class="line">   <span class="string">&quot;text&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">   &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="数据请求"><a href="#数据请求" class="headerlink" title="数据请求"></a>数据请求</h2><h3 id="小程序中的限制"><a href="#小程序中的限制" class="headerlink" title="小程序中的限制"></a>小程序中的限制</h3><p>出于安全性方面的考虑，小程序官方对数据接口的请求做出了如下两个限制：</p><p>①只能请求HTTPS类型的接口</p><blockquote><p>在开发过程中，在详情—&gt;本地设置中可以勾选 不校验合法域名….即可解决此问题</p></blockquote><p>② 必须将接口的域名添加到信任列表中</p><p>需求描述：假设在自己的微信小程序中，希望请求 <a href="https://lhx.zzux.com/%E5%9F%9F%E5%90%8D%E4%B8%8B%E7%9A%84%E6%8E%A5%E5%8F%A3">https://lhx.zzux.com/域名下的接口</a><br>配置步骤：登录微信小程序管理后台-→开发→开发设置-→服务器域名-&gt;修改request合法域名</p><p>注意事项：</p><p>① 域名只支持https 协议<br>② 域名不能使用IP地址或localhost<br>③ 域名必须经过 ICP 备案<br>④ 服务器域名一个月内最多可申请 5次修改</p><h3 id="发get-x2F-post请求"><a href="#发get-x2F-post请求" class="headerlink" title="发get&#x2F;post请求"></a>发get&#x2F;post请求</h3><p>调用微信小程序提供的 wx.request() 方法，可以发起 GET 请求，示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;https://lhx.zzux.com/api/get&#x27;</span>,<span class="comment">// 请求的接口地址，必须基于 https 协议</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="comment">//发post请求同理，只要把method改为post即可</span></span><br><span class="line">  <span class="attr">data</span>:&#123;<span class="comment">// 发送到服务器的数据</span></span><br><span class="line">name：<span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">22</span></span><br><span class="line">   &#125;,</span><br><span class="line">  <span class="attr">success</span>:<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;  <span class="comment">//请求成功之后的回调函数</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="页面加载时发请求"><a href="#页面加载时发请求" class="headerlink" title="页面加载时发请求"></a>页面加载时发请求</h3><p>在很多情况下，我们需要在页面刚加载的时候，自动请求一些初始化的数据。此时需要在页面的 onLoad事件中调用获取数据的函数，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">onLoad</span>: <span class="keyword">function</span>(<span class="params">options</span>)&#123;</span><br><span class="line">  <span class="comment">//要加this</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getSwiperList</span>()</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">getGridList</span>()</span><br><span class="line">&#125;，</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序知识点（一）</title>
      <link href="/mini-program.html"/>
      <url>/mini-program.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h3 id="项目的基本组成结构"><a href="#项目的基本组成结构" class="headerlink" title="项目的基本组成结构"></a>项目的基本组成结构</h3><p><img src="https://s1.ax1x.com/2022/11/28/zaDSiR.png" alt="根目录文件"></p><h3 id="小程序页面的组成部分"><a href="#小程序页面的组成部分" class="headerlink" title="小程序页面的组成部分"></a>小程序页面的组成部分</h3><p>小程序官方建议把所有小程序的页面，都存放在&#x3D;&#x3D;pages目录&#x3D;&#x3D;中，以单独的文件夹存在，如图</p><p><img src="https://s1.ax1x.com/2022/11/28/zaDCz6.png" alt="页面文件"></p><h2 id="小程序的配置文件"><a href="#小程序的配置文件" class="headerlink" title="小程序的配置文件"></a>小程序的配置文件</h2><blockquote><p>JSON是一种数据格式，在实际开发中，JSON总是以配置文件的形式出现。小程序项目中也不例外：通过不同的 .Json 配置文件，可以对小程序项目进行不同级别的配置。</p></blockquote><p>小程序项目中有4种配置文件，分别是：</p><ol><li><p>项目根目录中的 app.json 配置文件</p><blockquote><p>app.json是当前小程序的全局配置，包括了小程序的所有页面路径、窗口外观、界面表现、底部tab等。</p><p><img src="https://s1.ax1x.com/2022/11/28/zaDZod.png" alt="app.json"></p></blockquote></li><li><p>项目根目录中的 project.config.json 配置文件</p><blockquote><p>project.config.json用来记录我们对小程序开发工具所做的个性化配置</p><ul><li>setting 中保存了编译相关的配置</li><li>projectname 中保存的是项目名称(不影响小程序的名称)</li><li>appid 中保存的是小程序的账号ID</li></ul></blockquote></li><li><p>项目根目录中的 sitemap.json 配置文件</p><blockquote><p>这是微信开放的小程序内搜索，类似于PC网页的SEO。sitemap.json文件用于配置小程序页面是否允许微信索引。</p><p>默认是所有页面都允许被索引，如果要设置所有页面都不允许索引，把配置文件中 “action” : “allow” 改为 ”disallow“即可。</p></blockquote></li><li><p>每个页面文件夹中的.json配置文件</p><blockquote><p>小程序的每个页面都可以使用.json文件来对本页面的窗口外观进行配置，页面中的配置项会覆盖app.json 的 window 中相同的配置项。</p><p>如下图的例子，我们页面的 json 配置就覆盖了根目录的 app.json 配置</p><p><img src="https://s1.ax1x.com/2022/11/28/zaDQQf.png" alt="页面json"></p></blockquote></li></ol><h2 id="新建小程序页面"><a href="#新建小程序页面" class="headerlink" title="新建小程序页面"></a>新建小程序页面</h2><p>只需要在 app.json –&gt; pages 中新增页面的存放路径，小程序开发者工具可以帮我们自动创建对应的页面文件。如下图：</p><p><img src="https://s1.ax1x.com/2022/11/28/zaDGwQ.png" alt="新建页面"></p><h2 id="修改项目首页"><a href="#修改项目首页" class="headerlink" title="修改项目首页"></a>修改项目首页</h2><p>小程序的首页默认是 app.json –&gt; pages 数组中的第一个，想要修改项目的首页，我们只需要调整路径的先后顺序即可。比如我们想把刚创建的 home 作为项目首页的话就可以把 home 的路径放在第一行即可。</p><p><img src="https://s1.ax1x.com/2022/11/28/zaDJoj.png" alt="修改首页"></p><h2 id="WXML和HTML的区别"><a href="#WXML和HTML的区别" class="headerlink" title="WXML和HTML的区别"></a>WXML和HTML的区别</h2><ul><li>标签名不同</li></ul><blockquote><p>HTML：  div、  span、img、 a</p><p>WXML：view、text、image、navigator</p></blockquote><ul><li>属性节点不同</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HTML:  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span>&gt;</span>超链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">WXML:  <span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/home/home&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>提供了类似vue中的模板语法</li></ul><blockquote><p>数据绑定</p><p>列表渲染</p><p>条件渲染</p></blockquote><h2 id="WXSS和CSS的区别"><a href="#WXSS和CSS的区别" class="headerlink" title="WXSS和CSS的区别"></a>WXSS和CSS的区别</h2><ul><li>新增了rpx尺寸单位</li></ul><blockquote><p>CSS中需要手动进行像素单位换算，如rem</p><p>WXSS在底层支持新的尺寸单位rpx，在不同大小的屏幕上，小程序会自动进行换算</p></blockquote><ul><li>提供了全局的样式和局部样式</li></ul><blockquote><p>项目根目录中的app.wxss会作用于所有小程序页面</p><p>局部页面的.wxss样式仅对当前页面生效</p></blockquote><ul><li>WXSS仅支持部分CSS选择器</li></ul><blockquote><p>.class和#id</p><p>element</p><p>并集选择器、后代选择器</p><p>::after和::before等伪类选择器</p></blockquote><h2 id="小程序JS逻辑交互"><a href="#小程序JS逻辑交互" class="headerlink" title="小程序JS逻辑交互"></a>小程序JS逻辑交互</h2><ul><li>小程序中.js文件的分类</li></ul><blockquote><p>小程序中的JS文件分为三大类，分别是：</p></blockquote><ol><li>app.js               –&gt;是整个小程序项目的入口文件，通过调用App()函数来启动整个小程序</li><li>页面的.js文件     –&gt;是页面的入口文件，通过调用Page()函数来创建并运行页面</li><li>普通的.js文件     –&gt;是普通的功能模块文件，用来封装公共的函数或者属性供页面使用</li></ol><h2 id="小程序的启动步骤"><a href="#小程序的启动步骤" class="headerlink" title="小程序的启动步骤"></a>小程序的启动步骤</h2><ol><li>把小程序的代码包下载到本地</li><li>解析app.json全局配置文件</li><li>执行app.js小程序入口文件，调用App()创建小程序实例</li><li>渲染小程序首页</li><li>小程序启动完成</li></ol><h2 id="小程序页面渲染过程"><a href="#小程序页面渲染过程" class="headerlink" title="小程序页面渲染过程"></a>小程序页面渲染过程</h2><ol><li>加载解析页面的.json配置文件</li><li>加载页面的.wxml模板和.wxss样式</li><li>执行页面的.js文件，调用Page()创建页面实例</li><li>页面渲染完成</li></ol><h2 id="小程序组件"><a href="#小程序组件" class="headerlink" title="小程序组件"></a>小程序组件</h2><p>小程序中的组件也是由宿主环境提供的，主要分为九大类</p><ol><li><p>视图容器</p><details><summary>展开/收起</summary>    <p>        view------------------------------->普通视图区域,类似div，是一个块级元素    </p>    <p>        scroll-view------------------------>可滚动的视图区域，常用来实现滚动列表    </p>    <p>        swiper和swiper-item---------------->轮播图容器组件 和 轮播图item组件    </p></details></li><li><p>基础内容</p><details><summary>展开/收起</summary>    <h4>text</h4>    <p>      文本组件，类似html中的span，行内元素，加selectable属性支持长按选中操作    </p>    <h4>rich-text</h4>    <p>        富文本组件，通过nodes属性节点支持把HTML字符串渲染成WXML结构    </p>    <h4>button</h4>    <p>        按钮，功能比HTML的button丰富，通过open-type属性可以调用微信提供的各种功能（客服、转发、获取用户授权、获取用户信息等）    </p>    <h4>image</h4>    <p>       图片组件，image组件默认宽度约300px，高度约240px    </p>    <img src="https://s1.ax1x.com/2022/11/28/za0whq.png">    <h4>navigator</h4>    <p>      页面导航组件，类似于HTML中的a链接    </p></details></li><li><p>表单组件</p></li><li><p>导航组件</p></li><li><p>媒体组件</p></li><li><p>map地图组件</p></li><li><p>canvas画布组件</p></li><li><p>开放能力</p></li><li><p>无障碍访问</p></li></ol><h2 id="小程序API"><a href="#小程序API" class="headerlink" title="小程序API"></a>小程序API</h2><p>小程序官方把API分为了如下三大类</p><ol><li>事件监听API<ul><li>特点：以 on 开头，用来监听某些事件的触发</li><li>比如：wx.onWindowResize(function callback)监听窗口尺寸变化事件（wx相当于浏览器里的window）</li></ul></li><li>同步API<ul><li>特点1：以Sync结尾的API都是同步API</li><li>特点2：同步API的执行结果，可以通过函数返回值直接获取，如果执行出错会抛出异常</li><li>比如：wx.setStorageSync(‘key’,’value’)向本地存储中写入内容</li></ul></li><li>异步API<ul><li>特点：类似于jQuery 中的 $.ajax(options)函数，需要通过success、fail、complete接收调用的结果</li><li>比如：wx.request()发起网络请求，通过success回调函数接收数据</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的缓存机制</title>
      <link href="/chrome-cache.html"/>
      <url>/chrome-cache.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>浏览器会将请求后的资源进行存储为离线资源，当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>减少了不必要的数据传输，降低服务器压力</li><li>加快了客户端访问速度</li><li>增强用户体验</li></ul><h2 id="概览图"><a href="#概览图" class="headerlink" title="概览图"></a>概览图</h2><p><img src="https://s1.ax1x.com/2022/08/03/vZY1Ts.png" alt="网页缓存机制"></p><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><blockquote><p>指定一个具体的时间过期，只要日期没到就可以继续用，不向服务端发请求，强制使用缓存。</p><p>强缓存（有效期或终止日期、最后过期时间）。</p></blockquote><p>实现方式</p><blockquote><p>后端在响应头中返回 Expires 和 Cache-Control</p></blockquote><p><code>Expires</code>：</p><blockquote><p>http协议1.0的字段，缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</p><p>浏览器：使用expires到期时间和本地时间对比，如果本地时间被修改或者和服务器时间差距较大，会造成不准确的问题。</p><p>比如：设定过期时间2023年1月1日00:00:00，但是我们本地时间改了会有问题。</p></blockquote><p><code>Cache-Control</code>:</p><blockquote><p>Cache-Control是http1.1的字段，它约定的时间是相对时间。</p><p>比如：五天后过期，这么一来我们本地时间被修改也不会出问题。</p></blockquote><p>如果两者同时存在，那么Cache-Control比Expires优先级高。</p><blockquote><p>强制缓存时间到了并不一定会重新发送请求，而是会继续走协商缓存。</p></blockquote><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><blockquote><p>当强缓存失效后会使用协商缓存；协商缓存是由服务器决定是否使用缓存。</p></blockquote><p>1.向服务器发送请求资源并携带标识</p><ul><li>Etag字段：表示请求资源在服务器的唯一标识，浏览器可以根据Etag值缓存数据，下次请求的时候以if-None-Match字段请求</li><li>Last-Modified字段：用于标记请求资源的最后一次修改时间。</li></ul><p>2.浏览器会判断浏览器缓存的资源是否真的失效，是否需要更新</p><ul><li>如果失效，服务端数据已经更新：</li><li>服务器返回状态码200，重新返回新资源和缓存标识</li><li>浏览器再次存入缓存</li><li>后续再次从强缓存开始</li></ul><p>3.缓存时间到了，资源没更新，服务器就直接返回304，继续使用本地缓存。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是Vuex?</title>
      <link href="/fe-vuex.html"/>
      <url>/fe-vuex.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是vuex"><a href="#什么是vuex" class="headerlink" title="什么是vuex"></a>什么是vuex</h2><p>vuex官方是这么介绍的</p><blockquote><p> Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式 + 库。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p></blockquote><p>vuex是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间数据的共享。</p><h2 id="使用vuex的好处"><a href="#使用vuex的好处" class="headerlink" title="使用vuex的好处"></a>使用vuex的好处</h2><p>1.能够在vuex中集中管理共享的数据，易于开发和后期维护。</p><p>2.能够高效地实现组件之间的数据共享，提高开发效率。</p><p>3.vuex中存储的数据都是响应式的，能够实时保持数据与页面同步。</p><h2 id="使用vuex的场景"><a href="#使用vuex的场景" class="headerlink" title="使用vuex的场景"></a>使用vuex的场景</h2><p>一般来说，只有组件之间共享的数据才有必要存储到vuex中，组件的私有数据依旧存储在组件自身的data中即可。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store =<span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line"><span class="comment">//state中存放的就是全局共享的数据</span></span><br><span class="line"><span class="attr">state</span>:&#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Vuex的核心概念"><a href="#Vuex的核心概念" class="headerlink" title="Vuex的核心概念"></a>Vuex的核心概念</h2><p><a href="https://imgtu.com/i/jXCy6J"><img src="https://s1.ax1x.com/2022/07/23/jXCy6J.png" alt="vue官网图"></a></p><blockquote><p>vuex的核心概念：state、mutations、actions、getters、modules。上图是官网上的流程图，我们来分析一下每一环的作用</p></blockquote><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><blockquote><p>单一状态树，state提供唯一的公共数据源，提供唯一公共数据</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建store数据源，提供唯一公共数据</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line"><span class="attr">state</span>:&#123; <span class="attr">count</span>:<span class="number">0</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="组件访问state中数据的第一种方式"><a href="#组件访问state中数据的第一种方式" class="headerlink" title="组件访问state中数据的第一种方式"></a>组件访问state中数据的第一种方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.全局数据名称</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>当前count值为：&#123;&#123; $store.state.count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">//在template中this可以忽略</span><br></pre></td></tr></table></figure><h4 id="组件访问state中数据的第二种方式"><a href="#组件访问state中数据的第二种方式" class="headerlink" title="组件访问state中数据的第二种方式"></a>组件访问state中数据的第二种方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.在组件中从vuex按需导入mapstate函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapstate &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure><p>通过刚才导入的mapstate函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.将全局数据映射为当前组件的计算属性</span></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">...<span class="title function_">mapstate</span>([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line"><span class="comment">// ...为展开运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件中即可直接使用count</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>当前count值为：&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Mutations"><a href="#Mutations" class="headerlink" title="Mutations"></a>Mutations</h3><blockquote><p><strong>组件修改state中的数据</strong></p></blockquote><h4 id="错误操作"><a href="#错误操作" class="headerlink" title="错误操作"></a>错误操作</h4><p>我们想要实现点击按钮改变count的数值的话，可能会想给按钮添加一个@click事件让他数值+1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">数据&lt;p&gt;当前count值为：&#123;&#123; $store.<span class="property">state</span>.<span class="property">count</span> &#125;&#125;&lt;/p&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;countAdd&quot;</span>&gt;</span> +1 <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="title function_">countAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">count</span>++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意：mutations在处理异步操作时，能够引起页面的响应式变化，但是 devtools 无法进行监听。</p><h4 id="正确操作"><a href="#正确操作" class="headerlink" title="正确操作"></a>正确操作</h4><p>正确的操作应该是使用Mutation</p><blockquote><p>在vuex中只能通过mutation变更Store数据，不可以直接操作Store中的数据。</p><p>通过这种方式虽然操作起来繁琐了一些，但是可以集中监控所有数据的变化。不然到项目后期根本不知道是在哪个地方修改了数据，不利于维护。</p></blockquote><h4 id="定义mutation"><a href="#定义mutation" class="headerlink" title="定义mutation"></a>定义mutation</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      <span class="comment">//变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="触发mutation"><a href="#触发mutation" class="headerlink" title="触发mutation"></a>触发mutation</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发mutation</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">countAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//触发mutations的第一种方式</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>commit的作用就是调用某个mutation函数</p></blockquote><h4 id="触发mutation时传递参数"><a href="#触发mutation时传递参数" class="headerlink" title="触发mutation时传递参数"></a>触发mutation时传递参数</h4><p>如果我们不是让数值+1，而是加任意值该怎么做呢？可以在触发mutations时传递参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">//在这里加上形参</span></span><br><span class="line">    <span class="title function_">addN</span>(<span class="params">state,step</span>)&#123;</span><br><span class="line">      <span class="comment">//变更状态</span></span><br><span class="line">      state.<span class="property">count</span>+= step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="触发携带参数的mutation"><a href="#触发携带参数的mutation" class="headerlink" title="触发携带参数的mutation"></a>触发携带参数的mutation</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">countAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//触发mutations时携带参数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&#x27;addN&#x27;</span>,<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label blue">注意：在大多数情况下，传递的参数（载荷）应该是一个对象，这样可以包含多个字段并且记录的mutation会更易读</mark> <h4 id="触发mutations的第二种方式"><a href="#触发mutations的第二种方式" class="headerlink" title="触发mutations的第二种方式"></a>触发mutations的第二种方式</h4><p>上面this.$store.commit()是出发mutations的第一种方式，下面介绍一下第二种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从vuex中按需导入mapMutations函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure><p>通过导入的mapMutations函数，将需要的mutations函数映射为当前组件的methods方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  ...<span class="title function_">mapMutations</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>]),</span><br><span class="line">  <span class="title function_">countAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//可以直接调用add或者addN</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">add</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">addN</span>(<span class="number">5</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><blockquote><p>如果通过异步操作变更数据，建议（必须）通过Action，而不能使用Mutation。但是在Action中还是要通过触发Mutation的方式间接变更数据。</p></blockquote><p>不要在mutations中执行异步操作，比如想点击按钮一秒后再让数据变化，在mutation中写定时器这种操作是有问题的<br>我们的解决方案是用Action，它是专门用来处理异步任务的。这样 devtools 就能够进行跟踪，由 Actions 处理异步操作，具体的函数部分仍交由 Mutations 进行处理。</p><p><img src="https://s1.ax1x.com/2022/07/26/vSkneO.png" alt="同步任务，异步任务"></p><h4 id="定义Action"><a href="#定义Action" class="headerlink" title="定义Action"></a>定义Action</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line"> <span class="comment">//省略其他代码</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">state</span>)&#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">  <span class="comment">//context：上下文，默认写法</span></span><br><span class="line">    <span class="title function_">addAsync</span>(<span class="params">context</span>)&#123;</span><br><span class="line">      <span class="comment">//这里只负责执行setTimeout延迟操作</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="comment">//修改数据的操作提交给mutation</span></span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="触发Action"><a href="#触发Action" class="headerlink" title="触发Action"></a>触发Action</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">countAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//触发actions的第一种方式</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">    <span class="comment">//dispatch函数专门用来触发action</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="触发携带参数的Action"><a href="#触发携带参数的Action" class="headerlink" title="触发携带参数的Action"></a>触发携带参数的Action</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义Action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line"> <span class="comment">//省略其他代码</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="title function_">addN</span>(<span class="params">state,step</span>)&#123;</span><br><span class="line">      state.<span class="property">count</span> += step</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;，</span><br><span class="line">  <span class="attr">actions</span>:&#123;</span><br><span class="line">    <span class="comment">//传入形参</span></span><br><span class="line">    <span class="title function_">addAsync</span>(<span class="params">context,step</span>)&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//实参</span></span><br><span class="line">        context.<span class="title function_">commit</span>(<span class="string">&#x27;addN&#x27;</span>,step)</span><br><span class="line">      &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发Action</span></span><br><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">countAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//调用dispatch，携带参数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;addNAsync&#x27;</span>,<span class="number">5</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="触发mutations的第二种方式-1"><a href="#触发mutations的第二种方式-1" class="headerlink" title="触发mutations的第二种方式"></a>触发mutations的第二种方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从vuex中按需导入mapActions函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure><p>通过导入的mapActions函数，将需要的Actions函数映射为当前组件的methods方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  ...<span class="title function_">mapActions</span>([<span class="string">&#x27;add&#x27;</span>,<span class="string">&#x27;addN&#x27;</span>]),<span class="comment">//需要用哪个就定义哪个</span></span><br><span class="line">  <span class="title function_">countAdd</span>(<span class="params"></span>)&#123;</span><br><span class="line">   </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% label 注意：</span><br><span class="line"><span class="comment">//...mapActions([&#x27;add&#x27;,&#x27;addN&#x27;]) 这里的add和addN已经被映射为当前组件的方法，可以直接绑定在click事件上</span></span><br><span class="line">如：&lt;button @click=<span class="string">&quot;addN(5)&quot;</span>&gt;+<span class="number">5</span> acync&lt;/button&gt; green %&#125;</span><br></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><blockquote><p>Getter用于对Store中的数据进行加工处理形成新的数据，不会修改Store中的原数据。类似于计算属性，在数据展示前进行一些变化处理，具有缓存功能，能够提高运行效率。</p></blockquote><h4 id="定义Getter"><a href="#定义Getter" class="headerlink" title="定义Getter"></a>定义Getter</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>:<span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">showNum</span>: <span class="function"><span class="params">state</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;当前最新的数量是【&#x27;</span>+ state.<span class="property">count</span> +<span class="string">&#x27;】&#x27;</span>  </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用getters的第一种方式"><a href="#使用getters的第一种方式" class="headerlink" title="使用getters的第一种方式"></a>使用getters的第一种方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>.名称</span><br><span class="line">&lt;p&gt; &#123;&#123; $store.<span class="property">getter</span>.<span class="property">showNum</span> &#125;&#125; &lt;/p&gt;</span><br><span class="line"><span class="comment">//template中this可以省略</span></span><br></pre></td></tr></table></figure><h4 id="使用getters的第二种方式"><a href="#使用getters的第二种方式" class="headerlink" title="使用getters的第二种方式"></a>使用getters的第二种方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>:&#123;</span><br><span class="line">  ...<span class="title function_">mapGetters</span>(&#123;<span class="string">&#x27;showNum&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里vuex中的核心我们已经都了解了，那我们再总结一下</p><p><img src="https://s1.ax1x.com/2022/07/25/jvJVje.png" alt="总结"></p><h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><blockquote><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store对象就有可能变得相当臃肿。</p></blockquote><p>所以，vuex允许我们将state分割成模块（module），每个模块拥有自己的state、mutation、action、getter甚至是嵌套子模块—-从上至下进行同样方式的分割。</p><p><img src="https://s1.ax1x.com/2022/09/04/voq1mT.png" alt="module"></p><p>在项目实际使用中，我们一般在store文件夹中创建一个modules文件夹，把每个modules单独写为一个js文件，然后在index.js中import引入这些js文件即可。</p><p><img src="https://s1.ax1x.com/2022/09/04/voqD0O.png" alt="模块化写法"></p><p>模块化的vuex</p><p><img src="https://s1.ax1x.com/2022/09/04/vTZ5zq.png" alt="vuex模块化"></p><h2 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h2><p>MapStates</p><p>MapMutations</p><p>MapActions</p><p>MapGetters</p><h2 id="完结撒花🎉"><a href="#完结撒花🎉" class="headerlink" title="完结撒花🎉"></a>完结撒花🎉</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(不是广告)苹果手机免越狱微信双开</title>
      <link href="/iphone-wechat.html"/>
      <url>/iphone-wechat.html</url>
      
        <content type="html"><![CDATA[<p> <strong>苹果免越狱微信双开</strong></p><blockquote><p>事情的起因是我姐姐因工作需要两个微信，但是众所周知苹果手机官方是没有双开这个功能的，并且由于微信系统封闭，所以很难像安卓手机一样轻松的解决，在网上看了很多教程总结出一个比较好用的。</p></blockquote><mark class="hl-label pink">至于我为什么不用爱思助手</mark> ，爱思助手看起来简单，但是后续比较繁琐，每七天续签的时候还要重新签名，重新安装一次。<p>这个方法只是第一次操作稍微麻烦一点，但是后续只需要电脑和手机在同一网络下就可以了，续签是自动的，不用重新签名，不用重新安装，不用数据线插到电脑上！</p><p> <strong>废话少说直接上教程</strong></p><h2 id="下载最新版本iTunes、iCloud"><a href="#下载最新版本iTunes、iCloud" class="headerlink" title="下载最新版本iTunes、iCloud"></a>下载最新版本iTunes、iCloud</h2><p><a href="https://www.apple.com/itunes/download/win64">点我下载iTunes</a>。</p><p>或者去iTunes官网<a href="https://www.apple.com.cn/itunes/">https://www.apple.com.cn/itunes/</a></p><p><a href="https://updates.cdn-apple.com/2020/windows/001-39935-20200911-1A70AA56-F448-11EA-8CC0-99D41950005E/iCloudSetup.exe">点我下载iCloud</a>。</p><p>或者去iCloud官网<a href="https://support.apple.com/zh-cn/HT204283">https://support.apple.com/zh-cn/HT204283</a></p><h2 id="下载安装Altstore"><a href="#下载安装Altstore" class="headerlink" title="下载安装Altstore"></a>下载安装Altstore</h2><p>官网地址<a href="https://altstore.io/">https://altstore.io</a></p><h2 id="安装注意事项"><a href="#安装注意事项" class="headerlink" title="安装注意事项"></a>安装注意事项</h2><p><strong>注意：上面这三个软件安装的时候，<mark class="hl-label orange">最好：右键-用管理员身份运行</mark>  （altstore先解压出来安装），要不然可能会出现问题。</strong></p><h2 id="连接手机"><a href="#连接手机" class="headerlink" title="连接手机"></a>连接手机</h2><p> <strong>安装完之后三个软件都打开（Altstore没有应用界面，电脑右下角有菱形图标就代表已经启动了），然后把手机连上电脑，iTunes上对当前电脑授权</strong><br><img src="https://s1.ax1x.com/2022/07/10/jsMoWT.png" alt="jsMoWT.png"></p><p><strong>手机弹窗点信任</strong><br><img src="https://s1.ax1x.com/2022/07/10/jsM7SU.png" alt="jsM7SU.png"><br> <strong>iTunes连接成功后把这两个同步选项勾选上</strong><br><img src="https://s1.ax1x.com/2022/07/10/jsM5F0.png" alt="jsM5F0.png"></p><h2 id="手机安装Altstore"><a href="#手机安装Altstore" class="headerlink" title="手机安装Altstore"></a>手机安装Altstore</h2><p><strong>在右下角任务栏，右键AltStore选择install AltStore - 你的iphone,上面步骤中如果需要输入id和密码正常操作就可以</strong></p><p><img src="https://s1.ax1x.com/2022/07/10/jsQ29K.png" alt="jsQ29K.png"></p><p>等待一会儿，如果提示installation succeeded就代表安装成功了。这时候你手机上应该成功安装上了altstore，安装完成后，需要在手机系统设置内选择“通用”-“描述文件与设备管理”-进行信任证书。</p><p><img src="https://s1.ax1x.com/2022/07/10/jsQ7Nt.png" alt="jsQ7Nt.png"></p><h2 id="重头戏：微信二号"><a href="#重头戏：微信二号" class="headerlink" title="重头戏：微信二号"></a>重头戏：微信二号</h2><h2 id="下载我修改好的微信"><a href="#下载我修改好的微信" class="headerlink" title="下载我修改好的微信"></a>下载我修改好的微信</h2><p><strong>这一步真的是折腾了好久，之前在网上找的教程要么是没有微信安装包要么是安装包用不了，一直提示the app name is invalid或者 the app is invalid，最后终于修改打包出来了一个能用的</strong></p><p>纯净版：链接: <a href="https://pan.baidu.com/s/1Wt675l1_m7jp8qa-rbH7sA?pwd=lhxd">https://pan.baidu.com/s/1Wt675l1_m7jp8qa-rbH7sA?pwd=lhxd</a> 提取码: lhxd</p><p>多功能版：链接: <a href="https://pan.baidu.com/s/1M3kafr1uiEJJaPNua_51Vw?pwd=lhxd">https://pan.baidu.com/s/1M3kafr1uiEJJaPNua_51Vw?pwd=lhxd</a> 提取码: lhxd </p><p>多功能共存版（上面两个版本会互相覆盖，这个能与上两个共存）：链接: <a href="https://pan.baidu.com/s/1JOEWr6J_CeJ84hL43YBkHQ?pwd=lhxd">https://pan.baidu.com/s/1JOEWr6J_CeJ84hL43YBkHQ?pwd=lhxd</a> 提取码: lhxd </p><h2 id="下载后发送到手机"><a href="#下载后发送到手机" class="headerlink" title="下载后发送到手机"></a>下载后发送到手机</h2><p>这一步最简单的办法是直接在电脑上用微信文件助手传给手机，然后手机接收完成打开方式选择第二个，也就是AleStore<br><img src="https://s1.ax1x.com/2022/07/11/jcJSxI.png" alt="jcJSxI.png"></p><h2 id="手机安装微信2号"><a href="#手机安装微信2号" class="headerlink" title="手机安装微信2号"></a>手机安装微信2号</h2><p><strong>手机端AltStore按步骤操作即可</strong><br>需要输入id和密码就正常输，最后看altStore里面有微信就代表成功了，这时候返回桌面就可以看到第二个微信就可以正常使用了</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意：此方法为个人签名，有效期只有七天，马上要过期的时候只要电脑和手机链接同一个wifi即可续签，记得每七天要续签一次</p><h2 id="续签失败解决办法"><a href="#续签失败解决办法" class="headerlink" title="续签失败解决办法"></a>续签失败解决办法</h2><p>22年8月12日更新：在用了一个多月之后，我姐发来一张图过来说出了问题不能续签了</p><p><img src="https://s1.ax1x.com/2022/08/12/vYgAV1.png" alt="报错"></p><p>这个提示说的是会话过期，嗯…等于没说，谁知道是什么玩意过期了，只能一点点排查，最后发现…</p><mark class="hl-label purple">我姐电脑上的iTunes不见了！？</mark> 据她所说她没删，这几天都没碰电脑😂<p>那么知道问题在哪解决起来就简单了，下面是我的操作步骤：</p><ul><li>先安装iTunes</li><li>iTunes打开把之前的操作做一遍，也就是连上手机后把那两个同步的选项给勾选上；</li><li>然后再点击AltStore——Install AltStore一路操作下去，需要输id和密码就输进去；</li><li>等待一会，电脑右下角提示installation succeeded就可以打开手机去点击update续签了；</li><li>这时候应该就能正常续签变成七天了</li><li>问题解决！🎉🎉🎉</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iPhone </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的远程控制软件</title>
      <link href="/remote-control.html"/>
      <url>/remote-control.html</url>
      
        <content type="html"><![CDATA[<h2 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h2><p><strong>如果需要我远程控制你的电脑的话，按照以下教程操作即可</strong></p><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>先下载远程控制软件ToDesk <a href="https://dl.todesk.com/windows/ToDesk_Lite_x64.exe">点我下载</a>或者去<a href="https://www.todesk.com/">官网</a>下载(精简版免安装)</p><p><img src="https://s1.ax1x.com/2022/07/07/jwNpVA.png" alt="推荐精简版" title="精简版免安装"></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>下载完打开软件，然后截图发给我（如下图）</p><p>注意：如果连接密码是隐藏的话，点击后边的小眼睛图标把密码显示出来</p><p><img src="https://s1.ax1x.com/2022/07/07/jwNk28.png" alt="软件截图" title="把图片发给我"></p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程控制 </tag>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/fe-copy.html"/>
      <url>/fe-copy.html</url>
      
        <content type="html"><![CDATA[<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝指的是：对基本类型的值拷贝，以及对象类型的地址拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> b = a</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//1</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b)</span><br></pre></td></tr></table></figure><p>这里a是基本类型，</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端综合面试题</title>
      <link href="/fe-mianshi.html"/>
      <url>/fe-mianshi.html</url>
      
        <content type="html"><![CDATA[<h2 id="link和-import的区别"><a href="#link和-import的区别" class="headerlink" title="link和@import的区别"></a>link和@import的区别</h2><ol><li><p>link是HTML标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等；@import是css语法，只有导入样式表的作用。</p></li><li><p>加载页面时，link会和HTML同时加载，而@import将会在页面加载完毕之后被加载。</p></li><li><p>兼容性区别，@import是CSS2.1才有的语法，故只可在IE5+才能识别；link标签作为HTML元素，不存在兼容性问题。</p></li><li><p>DOM操作，DOM可以操作link中的样式，而不可以操作@import中的样式。</p><mark class="hl-label red">网上有一种声音说link权重比@import高，其实并没有，具体大家可以自己实践。</mark> </li></ol><h2 id="img标签-alt和title的区别"><a href="#img标签-alt和title的区别" class="headerlink" title="img标签 alt和title的区别"></a>img标签 alt和title的区别</h2><p>title：鼠标移入图片显示的值<br>alt：图片无法加载时显示的图片<br>在SEO的层面上，爬虫抓取不到图片的内容，所以在写img标签的时候为了增加SEO效果可以用alt属性来描述这张图的内容或者关键词</p><h2 id="substr和substring的区别"><a href="#substr和substring的区别" class="headerlink" title="substr和substring的区别"></a>substr和substring的区别</h2><blockquote><p><strong>1.  substr 是从起始索引号开始提取指定长度的字符</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="title function_">substr</span>(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">//输出结果为bcd</span></span><br></pre></td></tr></table></figure><p>substr(<mark class="hl-label blue">1</mark> ,<mark class="hl-label green">3</mark> ) 即表示从b(索引号<mark class="hl-label blue">1</mark> )开始提取3（<mark class="hl-label green">3</mark> ）个字符。也可以说提取索引<mark class="hl-label blue">1</mark> 到索引为<mark class="hl-label green">3</mark> 的位置，取头取尾</p><blockquote><p><strong>2.  substring是提取字符串中两个指定索引号之间的字符。</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&quot;abcdefg&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(string.<span class="title function_">substr</span>(<span class="number">1</span>,<span class="number">3</span>)) <span class="comment">//输出结果为bc</span></span><br></pre></td></tr></table></figure><p>substring(<mark class="hl-label blue">1</mark> ,<mark class="hl-label green">3</mark> ) 即表示提取从(索引号<mark class="hl-label blue">1</mark> )到（索引号<mark class="hl-label green">3</mark> ）之间的字符（不包括<mark class="hl-label green">3</mark> ），取头不取尾。</p><h2 id="slice和splice的区别"><a href="#slice和splice的区别" class="headerlink" title="slice和splice的区别"></a>slice和splice的区别</h2><blockquote><p> 相同点：都是对数组进行截取。</p><p> 不同点：slice不会改变原数组，但是splice会直接改变原数组。</p></blockquote><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><blockquote><p><strong><code>slice()</code></strong> 方法返回一个新的数组对象，这一对象是一个由 <code>begin</code> 和 <code>end</code> 决定的原数组的<strong>浅拷贝</strong>（包括 <code>begin</code>，不包括<code>end</code>）。原始数组不会被改变。</p></blockquote><h3 id="splice"><a href="#splice" class="headerlink" title="splice"></a>splice</h3><blockquote><p><strong><code>splice()</code></strong> 方法通过删除或替换现有元素或者原地<code>添加</code>新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array.<span class="title function_">splice</span>(start[, deleteCount[, item1[, item2[, ...]]]])</span><br><span class="line"><span class="comment">//    起始索引  要删除的个数（可选） 要添加的元素</span></span><br></pre></td></tr></table></figure><h2 id="谷歌浏览器字体小于12px"><a href="#谷歌浏览器字体小于12px" class="headerlink" title="谷歌浏览器字体小于12px"></a>谷歌浏览器字体小于12px</h2><p>1.使用transform来解决，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>：scale(<span class="number">0.8</span>)</span><br></pre></td></tr></table></figure><p>transform除了会缩小字体外，也会缩小盒子的大小</p><p>2.使用zoom的方式，如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">td</span>&#123;<span class="attribute">font-size</span>:<span class="number">12px</span>;zoom:<span class="number">0.83</span>&#125;</span><br></pre></td></tr></table></figure><p>它不会有transform的问题，不会导致盒子缩放。且PC项目环境使用谷歌浏览器，可以支持zoom属性，移动端经测试也兼容。</p><h2 id="事件循环—宏任务微任务"><a href="#事件循环—宏任务微任务" class="headerlink" title="事件循环—宏任务微任务"></a>事件循环—宏任务微任务</h2><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>简单来说浅拷贝就是只<strong>拷贝一层</strong>。</p><p>深拷贝就不会像浅拷贝那样只拷贝一层，而是有多少层我就拷贝多少层</p><p><a href="https://blog.csdn.net/jiang7701037/article/details/98738487">https://blog.csdn.net/jiang7701037/article/details/98738487</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式与发布订阅模式</title>
      <link href="/watcher-release.html"/>
      <url>/watcher-release.html</url>
      
        <content type="html"><![CDATA[<p>或许以前认为订阅发布模式是观察者模式的一种别称，但是发展至今，概念已经有了不少区别。</p><p><img src="https://s1.ax1x.com/2022/07/28/vCgOAJ.png" alt="观察者模式-发布订阅模式"></p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote><p>在观察者模式中，只有两种主体： 观察者 (<code>watcher</code>)和被观察者(<code>dep</code>)也可以说发布者和订阅者。当对象间存在一对多关系时，则使用观察者模式。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>比如，当一个对象被修改时，会自动通知依赖它的对象。观察者模式属于行为型模式。降低了目标与观察者之间的耦合关系，目标与观察者之间建立了一套触发机制。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>它的主要缺点如下。 目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。 当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p><p>1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 </p><p>2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 </p><p>3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>vue 双向绑定实现原理</p><h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><p>有事件中心、发布者、订阅者三个成员；(事件中心的作用可以隔离发布者和订阅者，去除他们之间的依赖)</p><p>添加订阅、发布消息都是用的事件中心里面的方法，且数据存储和数据更新都是用的事件中心里面的方法；所以真正的观察者和发布者之间没有耦合。</p><p><a href="https://segmentfault.com/a/1190000040205212">https://segmentfault.com/a/1190000040205212</a></p><p><a href="https://segmentfault.com/a/1190000020169229">https://segmentfault.com/a/1190000020169229</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指向</title>
      <link href="/fe-this.html"/>
      <url>/fe-this.html</url>
      
        <content type="html"><![CDATA[<h2 id="this的概念"><a href="#this的概念" class="headerlink" title="this的概念"></a>this的概念</h2><blockquote><p>this是JavaScript的一个关键字，他是指函数执行过程中，自动生成的一个内部对象，是指当前的对象，只在当前函数内部使用。</p><p>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this指向的是window；当函数被作为某个对象的方法调用时，this就等于那个对象。</p></blockquote><ul><li><p>在全局环境中(非函数体内)，无论是否在严格模式，this都指向window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span> <span class="comment">//使用严格模式</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//window</span></span><br></pre></td></tr></table></figure></li><li><p>在普通函数中，this指向window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数在严格模式下，this指向undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="string">&#x27;use strict&#x27;</span> <span class="comment">//使用严格模式</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//undefined</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="variable language_">window</span>) <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure></li><li><p>在构造函数中，this指向创建的实例对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">a</span> = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">b</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">//Fn &#123;a: &#x27;1&#x27;, b: ƒ&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> <span class="title function_">fn</span>()</span><br><span class="line">    c.<span class="title function_">b</span>()</span><br></pre></td></tr></table></figure></li><li><p>箭头函数没有自己的this，他的this是继承而来，也就是箭头函数上级的this。</p></li><li><p>在对象中，this指向调用者</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">      <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    obj.<span class="title function_">fn</span>() <span class="comment">//指向obj这个对象</span></span><br></pre></td></tr></table></figure><ul><li>以事件绑定函数的形式调用时，this 指向绑定事件的对象</li></ul><h2 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h2><p>call&#x2F;apply&#x2F;bind都可以强制改变this的指向</p><p><strong>call和apply 都是立即执行函数，并且改变函数中的this，再并且给函数传递参数</strong></p><ul><li>call执行的函数，如果有参数，则以“,”方式一个个去添加</li><li>apply执行的函数，如果有参数，则以数组的方式来传递</li><li>bind并不会把函数立即执行，它是预先处理函数中的this和参数的</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue综合知识</title>
      <link href="/vue.html"/>
      <url>/vue.html</url>
      
        <content type="html"><![CDATA[<h2 id="MVVM的优势"><a href="#MVVM的优势" class="headerlink" title="MVVM的优势"></a>MVVM的优势</h2><ul><li>双向绑定，Model变化时，View也会自动变化，view发生更新，model也跟着更新。</li><li>减少了dom操作，因为我们只需要关注数据就可以。</li><li>mvvm设计思想降低了代码的耦合性，方便维护。</li></ul><h2 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h2><p>在父向子传值的时候，如果改变父组件的值，子组件会跟着同步更新，反之则不会。</p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>v-model，数据发生变化会同步到视图，视图发生变化会同步数据。</p><h2 id="watch和computed哪个可以异步"><a href="#watch和computed哪个可以异步" class="headerlink" title="watch和computed哪个可以异步"></a>watch和computed哪个可以异步</h2><p>watch是监听一个值的变化，然后执行对应的回调，watch支持异步。</p><p>计算属性(computed)不能进行异步操作，因为计算属性(computed)是通过return返回值传递参数 异步操作的时候return是没有意义的，异步函数的返回值都不是用return返回的，所以vue中的计算属性(computed)不能使用异步函数。</p><h2 id="route和-router的区别"><a href="#route和-router的区别" class="headerlink" title="$route和$router的区别"></a>$route和$router的区别</h2><p>区别</p><p>this.$router是全局路由器对象 </p><p>0this.$route是当前激活的路由对象，包含了当前的路由信息。</p><p>$route route是路由信息对象，里面主要包含路由的一些基本信息，包括name、meta、path、hash、query、params、fullPath、matched、redirectedFrom</p><p>$router router是VueRouter的实例，包含了一些路由的跳转方法，钩子函数等</p><h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>v-model底层原理实际上是分别利用了<code>v-bind用来绑定value的值</code>，用<code>v-on去绑定input标准事件</code>，这是事件用来监听当输入域内容发生变化的时候来执行一些事情。具体做的事情就是通过$event这个事件对象获取到最新的输入域的值，然后把最新的值赋值给旧的值，从而进行数据的更新。这样的话就完成了双向数据绑定。</p><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>什么是自定义指令</p><blockquote><p>除了核心功能默认内置的指令 (v-model 和 v-show)，Vue 也允许注册自定义指令,对普通 DOM元素进行底层操作，这时候就会用到自定义指令。</p></blockquote><p>为什么要有自定义指令？</p><blockquote><p>vue提供的系统指令满足不了我们的需求，所以我们需要自定义指令。</p></blockquote><p>如何自定义指令？</p><blockquote><p>自定义指令分为全局自定义指令和局部自定义指令。通过Vue.directive(全局);组件内设置directives(局部)。</p></blockquote><ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li>inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</li><li>update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生了改变，也可能没有，但是可以通过比较更新前后的值来忽略不必要的模板更新。</li></ul><p>一些自定义指令的应用场景：</p><blockquote><p>防抖、图片懒加载、一键 Copy的功能、拖拽、页面水印、权限校验、输入框自动聚焦、相对时间转换、下拉菜单</p></blockquote><h2 id="vue中通过索引直接修改数组中的某一项数据，页面是否更新"><a href="#vue中通过索引直接修改数组中的某一项数据，页面是否更新" class="headerlink" title="vue中通过索引直接修改数组中的某一项数据，页面是否更新"></a>vue中通过索引直接修改数组中的某一项数据，页面是否更新</h2><p>在vue中对 对象新添加属性，页面是否更新？</p><blockquote><p>不更新，如果想要解决这个问题，vm.$set(vm.list,1,’or’)或者Vue.set</p><p>但是vm.list[3].a &#x3D; 456,通过索引修改某一项的对象内部的属性是没问题的。</p></blockquote><h2 id="vue组件中的data为什么是一个函数，返回一个对象？"><a href="#vue组件中的data为什么是一个函数，返回一个对象？" class="headerlink" title="vue组件中的data为什么是一个函数，返回一个对象？"></a>vue组件中的data为什么是一个函数，返回一个对象？</h2><p>如果不是一个函数返回一个新的对象，组件如果多次使用，实际公用的是同一个数据。</p><p>但是如果是通过函数返回一个新的对象，这样的话，每个组件的使用数据是独立的&#x2F;</p>]]></content>
      
      
      <categories>
          
          <category> vue </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BFC？它的作用是什么以及怎么创建BFC区域</title>
      <link href="/fe-bfc.html"/>
      <url>/fe-bfc.html</url>
      
        <content type="html"><![CDATA[<h2 id="啥是BFC"><a href="#啥是BFC" class="headerlink" title="啥是BFC"></a>啥是BFC</h2><h2 id="看不明白的定义："><a href="#看不明白的定义：" class="headerlink" title="看不明白的定义："></a><strong>看不明白的定义：</strong></h2><p>BFC (Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><p><strong>官方文档到中是这么介绍的</strong>：</p><blockquote><p><code>一个BFC区域包含创建该上下文元素的所有子元素，但是不包括创建了新的BFC的子元素的内部元素，BFC是一块块独立的渲染区域，可以将BFC看成是元素的一种属性，拥有了这种属性的元素就会使他的子元素与世隔绝，不会影响到外部其他元素。</code></p></blockquote><h2 id="代码理解"><a href="#代码理解" class="headerlink" title="代码理解"></a>代码理解</h2><p>还不是很清楚什么意思？上代码！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span> <span class="attr">id</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;1&quot;</span> <span class="attr">id</span>=<span class="string">&quot;son&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假设father和son盒子都是BFC区域<br>id&#x3D;”father”这个BFC区域包含了所有 class&#x3D;”1”的盒子但<strong>不包含</strong>class&#x3D;”2”的盒子<br>id&#x3D;”son”的这个BFC区域则包含了所以class&#x3D;”2”的盒子。<br>那么总结下来可以得到如下结论：<br>1.每一个BFC区域只包括它的子元素，并不包括子元素的子元素。<br>2.每个BFC区域都是独立隔绝开来的，互相不会受到影响。</p><h2 id="怎么创建BFC？"><a href="#怎么创建BFC？" class="headerlink" title="怎么创建BFC？"></a>怎么创建BFC？</h2><ol><li>根元素</li><li>float属性不为none</li><li>overflow不为visible</li><li>position为absolute或fixed</li><li>display为inline-block， table-cell， table-caption， flex， inline-flex</li></ol><h2 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h2><p>既然知道了BFC是咋回事，也知道了怎么创建BFC，那么它的作用是什么呢？</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>浮动会导致父元素高度塌陷，相信刚开始学html的同学们都记得overflow: hidden可以清除浮动，但是听说BFC之前却不清楚原理，经过上边的解释后就知道了是因为在BFC区域内子元素是不会影响到外部元素的。</p><h3 id="解决外边距塌陷"><a href="#解决外边距塌陷" class="headerlink" title="解决外边距塌陷"></a>解决外边距塌陷</h3><p>前端布局离不开margin，那么肯定会遇到外边距塌陷的问题</p><p><img src="https://s1.ax1x.com/2022/07/22/jOrC59.png" alt="外边距塌陷"></p><p>如图，我们给两个盒子分别设置了100px的外边距，两个盒子之间的外边距应该有200px，但是现在只有100px，那么根据刚开始我们的理解，只要给这两个盒子都加一个父盒子并设置为BFC区域就应该能解决这个问题，马上动手验证</p><p><img src="https://s1.ax1x.com/2022/07/22/jOrNVg.png" alt="解决外边距塌陷"></p><p>可以看到果然是正确的解决了外边距塌陷的问题。</p><h3 id="解决包含塌陷"><a href="#解决包含塌陷" class="headerlink" title="解决包含塌陷"></a>解决包含塌陷</h3><p><img src="https://s1.ax1x.com/2022/07/22/jOsdeO.png" alt="包含塌陷"></p><p>从上图可以看出我本来是给子盒子margin-top让他离父盒子顶部30px，但是却导致子盒子带着父盒子整体往下跑了30px，我们想要的效果却没有出来，要实现我们想要的效果有两个办法，一就是用padding，二就是把父盒子变成BFC区域，我们当然是选择第二种</p><p><img src="https://s1.ax1x.com/2022/07/22/jOs7pn.png" alt="解决包含塌陷"><br>完美解决！</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><blockquote><p>解决塌陷问题，清除浮动，右边固定左边自适应。</p></blockquote><h3 id="暂时完结，后续再补充"><a href="#暂时完结，后续再补充" class="headerlink" title="暂时完结，后续再补充"></a>暂时完结，后续再补充</h3>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是浮动以及清除浮动的方法</title>
      <link href="/fe-float.html"/>
      <url>/fe-float.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是浮动"><a href="#什么是浮动" class="headerlink" title="什么是浮动"></a>什么是浮动</h2><p>浮动（float）：</p><blockquote><p>浮动会让元素脱离<code>文档流</code>，不占空间。</p><p>假如A元素浮动了，原本排在A元素之后的元素发现A元素不在这个文档流了，就会往上接，替代A元素的位置。但是文字并不会无视它，还会环绕A元素，也就是A元素没有脱离文字流，而如果使用position的绝对定位会连文字流也脱离文档流。</p></blockquote><p><code>文档流</code>的概念：</p><blockquote><p>HTML中的的元素按照 从左往右、从上到下的顺序进行排列的。</p></blockquote><h2 id="浮动的特性："><a href="#浮动的特性：" class="headerlink" title="浮动的特性："></a>浮动的特性：</h2><ul><li><p>浮动元素会脱离标准流（脱标），即浮动的盒子不再保留原先的位置。</p></li><li><p>浮动的元素会在一行内显示并且元素顶部对齐（除非宽度不够在一行才会换行）。</p></li><li><p>浮动的元素会具有行内块元素的特性。</p></li><li><p>设置了一样属性的浮动元素是紧挨着的，不会有缝隙。</p></li><li><p>浮动元素设置margin_top不会发生塌陷现象</p></li><li><p>给标准流元素设置margin-top时会发生margin塌陷</p></li></ul><h2 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h2><p><strong>方法1:固定宽高</strong></p><blockquote><p>给浮动的元素添加父级div盒子,再给父级盒子设置高度</p></blockquote><blockquote><ul><li>缺点:高度固定死了,无法做到自适应,不宜维护,不灵活</li><li>应用场景：基本不变的导航栏,固定栏;</li></ul></blockquote><p><strong>方法2:一起浮动</strong></p><blockquote><p>父元素也添加浮动,这样父元素也脱离文档流</p></blockquote><blockquote><p>缺点:后面的DIV盒子依然会塌陷到浮动元素下面</p></blockquote><p><strong>方法3:额外标签法</strong><br> 在浮动的元素最后添加一个空div标签,里面设置style&#x3D;’clear:both’;触发bfc机制</p><p>优点： 通俗易懂，书写方便</p><p>缺点： 添加许多无意义的标签，结构化较差<br>注意： 要求这个新的空标签必须是块级元素。</p><p><strong>方法4:父级添加overflow：</strong></p><p>给父级添加 overflow 属性，将其属性值设置为 hidden、auto 或 scroll。</p><ul><li>优点：代码简洁</li><li>缺点：无法显示溢出的部分</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js数据类型和数据类型检测</title>
      <link href="/data-type.html"/>
      <url>/data-type.html</url>
      
        <content type="html"><![CDATA[<h2 id="js数据类型和数据类型检测"><a href="#js数据类型和数据类型检测" class="headerlink" title="js数据类型和数据类型检测"></a>js数据类型和数据类型检测</h2><h3 id="js数据类型"><a href="#js数据类型" class="headerlink" title="js数据类型"></a>js数据类型</h3><blockquote><ol><li>简单（基本）类型：String、Number、Boolean、Undefined、Null、Symbol</li><li>引用（复杂）类型：Object、Array、Function</li></ol></blockquote><h3 id="检测数据类型方法"><a href="#检测数据类型方法" class="headerlink" title="检测数据类型方法"></a>检测数据类型方法</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><strong>typeof</strong></h4><blockquote><p>  一般用于检测基本数据类型，因为它检测引用（复杂）数据类型都会返回Objcet</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">1</span>) <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span>) <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>) <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>) <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>) <span class="comment">// object</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fun) <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> arr)<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>了解一下：typeof null返回值是object，因为js中的数据在底层是以二进制存储，如果前三位为0，那么就会判定为object，而null的所有都为0 ，所以null会被检测为object</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><blockquote><p>instanceof是一个双目判断运算符，a instanceOf b ，用来检测构造函数的prototype属性是否出现在对象原型链中的任意位置，返回一个布尔值。</p></blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="keyword">function</span>(<span class="params"></span>)&#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fun <span class="keyword">instanceof</span> <span class="title class_">Function</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> obj =&#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">let</span> arr = [ ]</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>) <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这个方法主要是用来检测复杂数据类型的，不能用来检测基本数据类型，可以理解为用来检测构造函数的prototype属性是否出现在对象原型链中的任意位置，只要在当前实例的原型链上，我们用其检测出来的结果都是 true。在类的原型继承中，我们最后检测出来的结果未必准确。。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span> <span class="comment">//false </span></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>instanceof运算符直接访问的变量的原始值，不会自动建立包装类。因此不能用来判断基本数据类型。</p><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h4><blockquote><p><strong>语法：</strong>实例.constructor</p><p>对象的原型链下（构造函数的原型下）有一个属性，叫constructor, <strong>constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。</strong></p><p>缺点：constructor并不可靠，因为它容易被修改。</p></blockquote><h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><blockquote><p>Object.prototype.toString.call()应该是目前最准确最常用的方式了，可以用来检测所有数据类型。在Object.prototype上有一个toString方法,这个方法执行的时候,会返回方法中this关键字对应数据值的数据类型,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object.prototype.toString() -&gt;返回的是 Object.prototype 的数据类型 -&gt;&quot;[object Object]&quot;</span></span><br><span class="line"><span class="comment">//f.toString() -&gt;返回的是f的数据类型 -&gt;&quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure><p>也就是，我想知道谁的所属类信息，我们就把这个toString方法执行，并且让this变为我们检测的这个数据值，那么方法返回的结果就是当前检测这个值得所属类信息 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="number">12</span>)<span class="comment">//[boject Number]</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="literal">true</span>)<span class="comment">//[boject Boolean]</span></span><br><span class="line">    <span class="comment">//&quot;[object Number]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object String]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Object]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Function]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Undefined]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Null]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line">    <span class="comment">//&quot;[object Boolean]&quot;</span></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> javaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--css篇</title>
      <link href="/fe-css.html"/>
      <url>/fe-css.html</url>
      
        <content type="html"><![CDATA[<h2 id="css权重优先级"><a href="#css权重优先级" class="headerlink" title="css权重优先级"></a>css权重优先级</h2><p>权重优先级从高到低：</p><ul><li><p>!important</p></li><li><p>id选择器</p></li><li><p>类选择器、属性选择器、伪类选择器</p></li><li><p>标签选择器、伪元素选择器</p></li><li><p>通配符选择器</p></li><li><p>继承</p></li></ul><h2 id="css3有哪些新特性"><a href="#css3有哪些新特性" class="headerlink" title="css3有哪些新特性"></a>css3有哪些新特性</h2><p>0.<code>flex布局</code></p><p>1.颜色：新增RGBA，HSLA模式</p><p>2.文字阴影（text-shadow）</p><p>3.<code>边框：圆角（border-radius)</code>、 边框阴影（box-shadow）</p><p>4.<code>盒子模型</code>：box-sizing</p><p>5.背景：background-size设置背景图片的尺寸、background-origin设置背景图片的原点、background-clip设置背景图片的裁切区域，以“,”分割可以设置多背景，用于自适应布局。</p><p>6.渐变：linear-gradient、radial-gradient</p><p>7.<code>过渡：transition</code>可实现动画</p><p>8.自定义动画</p><p>9.在css3中唯一引入的伪元素：selection</p><p>10.媒体查询、多栏布局</p><p>11.border-image</p><p>12.2D转换：transform</p><p>13.3D转换</p><h2 id="两栏布局右边固定左边自适应"><a href="#两栏布局右边固定左边自适应" class="headerlink" title="两栏布局右边固定左边自适应"></a>两栏布局右边固定左边自适应</h2><p>两个div盒子</p><p>第一种方式：flex布局</p><p>先给父盒子设置display:flex让两个子盒子一行显示，给右边盒子固定宽度，左边盒子flex:1</p><p>第二种方式：定位+overflow</p><h2 id="重绘与回流"><a href="#重绘与回流" class="headerlink" title="重绘与回流"></a>重绘与回流</h2><p>回流必定会引起重绘，重绘不一定会引起回流。</p><blockquote><p>回流（reflow）：当页面中的元素宽高、布局、显示、隐藏或元素内部文字结结构发生改变时，会影响自身及其父元素、甚至追溯到更多的祖先元素发生改变，则会导致元素内部、周围甚至整个页面的重新渲染，页面发生重构，回流就产生了。</p></blockquote><blockquote><p>   重绘（repaint）：元素的结构（宽高、布局、显示隐藏、内部文字大小）未发生改变，只是元素的外观样式发生改变，比如背景颜色、内部文字颜色、边框颜色等。此时会引起浏览器重绘，重绘的速度快于回流。</p></blockquote><h2 id="css实现三角形"><a href="#css实现三角形" class="headerlink" title="css实现三角形"></a>css实现三角形</h2><p><strong>使用boder属性</strong></p><p>给定一个宽度和高度都为 0 的元素，其 border 的任何值都会直接相交，我们可以利用这个交点来创建三角形。也就是说，border属性是三角形组成的，下面给每一边都提供不同的边框颜色：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.triangle</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid;</span><br><span class="line">    <span class="attribute">border-color</span>: orangered skyblue gold yellowgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将元素的长宽都设置为0，效果就是四个三角形组成的正方形，如果想要一个指向下面的三角形，可以让 border 的上边可见，其他边都设置为透明，其他方向同理。</p><h2 id="如何实现0-5像素"><a href="#如何实现0-5像素" class="headerlink" title="如何实现0.5像素"></a>如何实现0.5像素</h2><p>1.伪元素+scale</p><p>给容器设置伪元素，设置绝对定位，宽高200%，边框1px，然后使用transform:scale(0.5) 让伪元素缩小原来的一半，此时伪元素的边框和容器的边缘重合</p><p>2: 伪元素+背景 (适合设置一条边框，没办法展示圆角)<br>实现方式：给容器设置伪元素，设置绝对定位，高度1px，背景图设置线性渐变，一半有颜色一半透明，视觉上只有0.5px。</p><p>3: 利用阴影代替边框<br>特点：方便，能正常展示圆角，而且能实现0.1px等更细的边框，兼容性还行。</p><h2 id="盒子水平垂直居中"><a href="#盒子水平垂直居中" class="headerlink" title="盒子水平垂直居中"></a>盒子水平垂直居中</h2><p>1.纯flex</p><p>父盒子开启flex，主轴居中、侧轴居中即可</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">display: flex;</span><br><span class="line"></span><br><span class="line">justify-content: center;</span><br><span class="line"></span><br><span class="line">align-items: center;</span><br></pre></td></tr></table></figure><p>2.flex + margin</p><blockquote><p>父盒子 display: flex;</p><p>子盒子 margin: auto;</p></blockquote><blockquote><mark class="hl-label red">注意：</mark> 纯margin虽然也能实现，但是如果大小发生改变则会出问题</blockquote><p>3.定位 + transform</p><blockquote><p>子绝父相</p><p>给父盒子相对定位：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: relative;</span><br></pre></td></tr></table></figure><p>给子盒子绝对定位：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%,-50%); //减去自身的50%</span><br></pre></td></tr></table></figure></blockquote><p>4.定位 + margin</p><blockquote><p>子绝父相</p><p>给父盒子相对定位：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">position: relative;</span><br></pre></td></tr></table></figure><p>给子盒子绝对定位：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure></blockquote><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><blockquote><p>盒模型由内往外主要分为四个部分：内容、内边距、边框、外边距</p></blockquote><p><img src="https://s1.ax1x.com/2022/08/01/vAF4Fx.png" alt="盒模型"></p><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><blockquote><p>默认是标准盒模型，width和height只是内容的宽高，所以盒子的实际大小应加上：内边距、边框</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      * &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.father</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: skyblue;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">border</span>: <span class="number">10px</span> solid pink;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    //其他代码省略</span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://s1.ax1x.com/2022/08/01/vAEnL4.png" alt="盒模型面积"></p><p>所以盒子最终的宽高是240*240</p><h3 id="怪异盒模型-x2F-c3盒模型-x2F-ie盒模型"><a href="#怪异盒模型-x2F-c3盒模型-x2F-ie盒模型" class="headerlink" title="怪异盒模型&#x2F;c3盒模型&#x2F;ie盒模型"></a>怪异盒模型&#x2F;c3盒模型&#x2F;ie盒模型</h3><p>通过设置box-sizing: border-box;可以设置为怪异盒模型，实际盒子大小就是设置的宽高，包含内容+padding+border。</p><p><img src="https://s1.ax1x.com/2022/08/01/vAVeht.png" alt="怪异盒模型"></p><h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><h3 id="flex1"><a href="#flex1" class="headerlink" title="flex1"></a>flex1</h3><blockquote><p>flex1展开为：</p><p>flex-grow:1</p><p>flex-shink:1</p><p>flex-basis:0%</p></blockquote><p>1.<code>flex-grow</code> 是用来增大盒子的，比如，当父盒子的宽度大于子盒子的宽度，父盒子的剩余空间可以利用flex-grow来设置子盒子增大的占比。 </p><p>2.<code>flex-shink</code> 是用来设置子盒子超过父盒子的宽度后，进行缩小的比例值。</p><p>3.<code>flex-basis </code> 设置盒子的基准宽度，并且basis存在时会使width失效。（可以理解为basis比width优先级高）</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> css </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题--html篇</title>
      <link href="/FE-html.html"/>
      <url>/FE-html.html</url>
      
        <content type="html"><![CDATA[<h2 id="html5有哪些新特性？"><a href="#html5有哪些新特性？" class="headerlink" title="html5有哪些新特性？"></a>html5有哪些新特性？</h2><p>答：html5新增和移除了一些元素</p><p>新增了以下几大类元素：</p><p>内容元素：article、footer、header、nav、section。<br>表单控件：calendar、date、time、email、url、search。<br>控件元素：webworker, websockt, Geolocation。</p><p>移除的元素有下列这些：</p><p>显现层元素：basefont，big，center，font, s，strike，tt，u。<br>性能较差元素：frame，frameset，noframes。</p><p>HTML5已形成了最终的标准，概括来讲，它主要是关于图像，位置，存储，多任务等功能的增加。<br>新增的元素有绘画 canvas ，用于媒介回放的 video 和 audio 元素，本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失，而sessionStorage的数据在浏览器关闭后自动删除。<br>新的技术：canvas,svg,webworker, websocket, Geolocation</p><h2 id="对HTML语义化的理解"><a href="#对HTML语义化的理解" class="headerlink" title="对HTML语义化的理解"></a>对HTML语义化的理解</h2><p>答：</p><p>（1）HTML语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析；<br>（2）即使在没有样式CSS的情况下也能以一种文档格式显示，并且是容易阅读的；<br>（3）搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，有利于SEO；<br>（4）使阅读源代码的人更容易将网站分块，便于阅读、维护和理解。</p><h2 id="Doctype作用-严格模式混杂模式"><a href="#Doctype作用-严格模式混杂模式" class="headerlink" title="Doctype作用?严格模式混杂模式"></a>Doctype作用?严格模式混杂模式</h2><p>答：</p><p>（1）&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 <html> 标签之前。告知浏览器以何种模式来渲染文档。<br>（2）严格模式的排版和 JS 运作模式是以该浏览器支持的最高标准运行。<br>（3）在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。<br>（4）DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。</p><h2 id="浏览器内核的理解"><a href="#浏览器内核的理解" class="headerlink" title="浏览器内核的理解"></a>浏览器内核的理解</h2><p>答：</p><p> 浏览器内核（Rendering Engine），直译过来的意思是渲染引擎，它指浏览器最核心的部分，负责对网页语法的解释（如标准通用标记语言下的一个应用HTML、JavaScript）并渲染（显示）网页。</p><p> 所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染（显示）效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因。</p><h3 id="常见的内核"><a href="#常见的内核" class="headerlink" title="常见的内核"></a>常见的内核</h3><p>Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>Gecko内核：Netscape6及以上版本，FF,MozillaSuite&#x2F;SeaMonkey等。<br>Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为、Blink;]<br>Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]<br>EdgeHTML内核：Microsoft Edge。  [此内核其实是从MSHTML fork而来，删掉了几乎所有的IE私有特性]。</p><h2 id="对WEB标准以及W3C的理解"><a href="#对WEB标准以及W3C的理解" class="headerlink" title="对WEB标准以及W3C的理解"></a>对WEB标准以及W3C的理解</h2><p>Web标准一般是将结构、表现、行为独立分开，使其更具有模块化。</p><p>W3C标准是对web标准提出规范化要求，比如：标签字母要小写，双标签要闭合，标签不允许随意嵌套。</p><p>好处是：文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> html </category>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>element-ui知识</title>
      <link href="/element-ui.html"/>
      <url>/element-ui.html</url>
      
        <content type="html"><![CDATA[<h2 id="好记性不如烂笔头"><a href="#好记性不如烂笔头" class="headerlink" title="好记性不如烂笔头"></a>好记性不如烂笔头</h2><p>整理一下 element-ui 中常用的功能写法。</p><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局如果都写100%没意义，父级要有高度或宽度才行，可以给父级(最外层)设置100vh或者100vw最好。</p><h2 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h2><p>新版写法：v-slot&#x3D;”scope”</p><p><img src="https://s1.ax1x.com/2022/09/03/voB8oQ.png" alt="插槽写法"></p><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>最外层 要写:model和:rules</p><p>item层 要写prop</p><p>input层 要写v-model</p><p>注意：（prop和v-model）表单v-model写的名字和rule名字必须一样</p><p><img src="https://s1.ax1x.com/2022/09/03/voQnxA.png" alt="表单验证"></p><h2 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h2><p>在 <el-form>加上ref&#x3D;”loginFormRef”；给重置按钮加上reset点击事件；在methods里面设置reset方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">methods</span>:&#123;</span><br><span class="line">  <span class="title function_">reset</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//获取表单组件实现对象</span></span><br><span class="line">    <span class="comment">//对整个表单进行重置，将所有字段重置为初始值并移除校验结果</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">loginFormRef</span>.<span class="title function_">resetFields</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="validator-自定义校验规则"><a href="#validator-自定义校验规则" class="headerlink" title="validator(自定义校验规则)"></a>validator(自定义校验规则)</h2><p>validator是一个函数，其中有三个参数（rule(当前规则)，value（当前值），callback（回调函数））。</p><p>如下图，表单内只能写 1、2、3 其中的一个，写其他的会报错。</p><p><img src="https://s1.ax1x.com/2022/09/03/vo1gD1.png" alt="自定义校验"></p><h2 id="树状结构"><a href="#树状结构" class="headerlink" title="树状结构"></a>树状结构</h2><p><img src="https://s1.ax1x.com/2022/09/03/voBPsK.png" alt="树状结构写法"></p><p>这里默认必须是label，下级是children才能正常显示。如果后端返回的数据不是这样的，我们要修改一下告诉el-tree哪个是label，哪个是children，如下图。</p><p><img src="https://s1.ax1x.com/2022/09/03/voDFlq.png" alt="非label、children写法"></p><h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p><img src="https://s1.ax1x.com/2022/09/03/voD6HS.png" alt="dialog"></p><h2 id="提示框"><a href="#提示框" class="headerlink" title="提示框"></a>提示框</h2><p>使用场景大多数在created钩子函数或者登录状态提示等，有很多不同的版本，只提示不影响操作的；可以输入文字的、侧边弹出的等等。</p><p><img src="https://s1.ax1x.com/2022/09/03/voryx1.png" alt="无影响提示框"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目知识</title>
      <link href="/composite.html"/>
      <url>/composite.html</url>
      
        <content type="html"><![CDATA[<p>vue.config.js不是在src中写的代码，所以不能用import，export，default语法，只能用node.js的语法，因为脚手架cli是基于node开发的。</p><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize"></a>normalize</h2><blockquote><p>我们在开发的时候会发现很多样式都自带了各自特有的默认样式，而这样样式通常会被遗忘，导致样式调整起来很繁琐。为了让样式统一，我们在开发的时候通常会对一些元素进行样式重置，已避免默认样式影响开发。Normalize.css就是一个这样的CSS样式文件，<mark class="hl-label blue">它的作用就是让HTML元素更好的实现跨浏览器一致性。</mark> </p></blockquote><p>一句话总结就是：normalize可以让样式在所有浏览器中都保持一致。</p><h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h2><p>定义变量用 $</p><p>&amp;父级选择器和less没有区别</p><p>混入mixin</p><h2 id="样式穿透"><a href="#样式穿透" class="headerlink" title="样式穿透"></a>样式穿透</h2><ul><li>&#x2F;deep&#x2F;  在vue3之前可用</li><li>::v-deep  在vue3开始使用</li><li>deep()  具体不太清楚</li></ul><h2 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h2><p>其实Mixin不是Vue专属的，可以说它是一种思想，也可以说它就是混入的意思，在很多开发框架中都实现了Mixin(混入)。</p><blockquote><p>官方定义：混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p></blockquote><p>大白话解释：把组件的公共逻辑提取出来，那个组件需要用到时，直接将提取的这部分混入到组件内部即可。这样既可以减少代码冗余，也可以让后期维护起来更加容易。</p><p>简单应用：</p><p><img src="https://s1.ax1x.com/2022/09/04/voziCD.png" alt="mixin"></p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p> 优点：提高代码复用性；无需传递状态；维护方便，只需要修改一个地方即可；</p><p> 缺点：命名冲突；滥用的话后期很难维护；不好追溯源，排查问题稍显麻烦；不能轻易的重复代码；</p><h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>路由懒加载</p><p><img src="https://s1.ax1x.com/2022/09/04/voTfdH.png" alt="路由懒加载写法"></p><h2 id="登录校验"><a href="#登录校验" class="headerlink" title="登录校验"></a>登录校验</h2><p>二次校验，防止表单内容不合规还继续发送请求，validate返回的是一个promise</p><p><img src="https://s1.ax1x.com/2022/09/04/vo7r7Q.png" alt="二次校验"></p><h2 id="ajax-axios"><a href="#ajax-axios" class="headerlink" title="ajax(axios)"></a>ajax(axios)</h2><p>先在src目录下创建一个utils文件夹，在里面新建一个request.js文件。</p><p><img src="https://s1.ax1x.com/2022/09/04/vo7Oc6.png" alt="axios写法"></p><p>然后在src下创建一个api文件夹，里面是各个文件的请求。</p><p><img src="https://s1.ax1x.com/2022/09/04/voHVu8.png" alt="登录请求"></p><p>然后在页面当中引入接口并进行相应的操作</p><p><img src="https://s1.ax1x.com/2022/09/04/voHNE4.png" alt="登录接口"></p><h2 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h2><p>如果出现了跨域问题，因为一些原因后端没有解决的话，我们就可以用proxy来解决。方法就是在vue.config.js中配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:&#123;</span><br><span class="line">    <span class="comment">//当我们的本地请求有/api的时候，就会代理我们的请求地址向另外一个服务器发送请求</span></span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>:&#123;</span><br><span class="line">      <span class="attr">target</span>:<span class="string">&#x27;http://lhx.zzux.com&#x27;</span>  <span class="comment">//跨域请求的地址</span></span><br><span class="line">      changeOrigin：<span class="literal">true</span>            <span class="comment">//只有这个值为true的情况下 才表示开启跨域</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在环境变量文件 .env.development 中也要加上 &#x2F;api 或者每个接口前面都加上&#x2F;api，这样才能在proxy中匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">VUE_APP_BASE_URL</span>=/api</span><br></pre></td></tr></table></figure><p>如果项目中不需要api字段，可以在proxy中添加一行 pathRewrite</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>:&#123;</span><br><span class="line">  <span class="attr">proxy</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>:&#123;</span><br><span class="line">      <span class="attr">target</span>:<span class="string">&#x27;http://lhx.zzux.com&#x27;</span> </span><br><span class="line">      changeOrigin：<span class="literal">true</span> </span><br><span class="line">      <span class="attr">pathRewrite</span>:&#123;<span class="string">&#x27;^/api&#x27;</span>:<span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//在请求的时候就会把api给替换为空，等于去掉api了</span></span><br><span class="line">        <span class="comment">//pathRewrite 路径重写</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
